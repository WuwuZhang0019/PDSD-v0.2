实现节点间的数据流动和实时更新机制：

```rust
// 扩展MyNodeGraphApp以支持数据流向和实时更新
struct PowerDistributionApp {
    // 基础图数据和状态
    graph: egui_node_graph::Graph<PowerNodeData, PowerDataType, PowerValueType>,
    editor_state: GraphEditorState,

    // 组件库
    circuit_nodes: Vec<CircuitNodeData>,
    distribution_boxes: Vec<DistributionBoxNodeData>,
    main_system_nodes: Vec<MainSystemNodeData>,

    // 更新状态
    nodes_to_update: std::collections::HashSet<egui_node_graph::NodeId>,

    // 计算缓存
    calculation_cache: std::collections::HashMap<egui_node_graph::NodeId, PowerValueType>,
}

// 统一的节点数据枚举
#[derive(Debug, Clone)]
enum PowerNodeData {
    Circuit(CircuitNodeData),
    DistributionBox(DistributionBoxNodeData),
    MainSystem(MainSystemNodeData),
}

// 配电系统特有的数据类型
#[derive(Debug, Clone, PartialEq, Eq)]
enum PowerDataType {
    Power,
    Current,
    ComponentSpec,
    CableSpec,
    CircuitInfo,
    DistributionBoxInfo,
    SystemDiagram,
}

// 配电系统特有的值类型
#[derive(Debug, Clone)]
enum PowerValueType {
    Float(f64),
    String(String),
    CircuitInfo(CircuitNodeData),
    DistributionBoxInfo(DistributionBoxNodeData),
    SystemDiagram(SystemDiagram),
}

impl PowerDistributionApp {
    // 处理节点更新和数据流动
    fn propagate_updates(&mut self) {
        // 1. 确定需要更新的节点顺序（拓扑排序）
        let execution_order = self.perform_topological_sort();

        // 2. 按顺序更新节点
        for node_id in execution_order {
            if self.nodes_to_update.contains(&node_id) {
                self.update_node(node_id);

                // 3. 更新受影响的下游节点
                self.mark_downstream_nodes_for_update(node_id);
            }
        }

        // 4. 清除更新标志
        self.nodes_to_update.clear();
    }

    // 更新单个节点
    fn update_node(&mut self, node_id: egui_node_graph::NodeId) {
        let node = &mut self.graph.nodes[node_id];

        match &mut node.user_data {
            PowerNodeData::Circuit(circuit) => {
                // 更新配电回路节点
                circuit.calculate_current();
                circuit.select_components();
            },
            PowerNodeData::DistributionBox(box_node) => {
                // 收集所有连接到该配电箱的回路节点
                let mut connected_circuits = Vec::new();

                for (input_id, connected_output_id) in &self.graph.connections {
                    let input = &self.graph.inputs[*input_id];
                    if input.node == node_id {
                        // 找到输出节点
                        for (output_node_id, node) in &self.graph.nodes {
                            if node.outputs.values().any(|&id| id == *connected_output_id) {
                                if let PowerNodeData::Circuit(circuit) = &node.user_data {
                                    connected_circuits.push(circuit.clone());
                                }
                            }
                        }
                    }
                }

                // 更新配电箱数据
                let mut circuit_data = connected_circuits.iter_mut().collect::<Vec<_>>();
                box_node.calculate_total_power(&connected_circuits);
                box_node.auto_number_circuits(&mut circuit_data);
                box_node.balance_three_phases(&mut circuit_data);

                // 更新回路数据
                for (i, circuit) in connected_circuits.iter().enumerate() {
                    // 这里应该找到对应的节点并更新
                    // 简化处理，实际应用中需要维护节点映射
                }
            },
            PowerNodeData::MainSystem(system_node) => {
                // 收集所有连接的配电箱节点
                let mut connected_boxes = Vec::new();

                for (input_id, connected_output_id) in &self.graph.connections {
                    let input = &self.graph.inputs[*input_id];
                    if input.node == node_id {
                        // 找到输出节点
                        for (output_node_id, node) in &self.graph.nodes {
                            if node.outputs.values().any(|&id| id == *connected_output_id) {
                                if let PowerNodeData::DistributionBox(box_node) = &node.user_data {
                                    connected_boxes.push(box_node.clone());
                                }
                            }
                        }
                    }
                }

                // 生成系统图
                let diagrams = system_node.auto_map_distribution_boxes(&connected_boxes);

                // 存储生成的系统图
                for diagram in diagrams {
                    // 实际应用中应将系统图关联到节点
                }
            },
        }
    }

    // 标记下游节点需要更新
    fn mark_downstream_nodes_for_update(&mut self, node_id: egui_node_graph::NodeId) {
        // 找到所有依赖此节点的下游节点
        for (input_id, connected_output_id) in &self.graph.connections {
            // 检查是否是当前节点的输出
            let node = &self.graph.nodes[node_id];
            if node.outputs.values().any(|&id| id == *connected_output_id) {
                // 找到输入节点
                let input = &self.graph.inputs[*input_id];
                let downstream_node_id = input.node;

                // 标记为需要更新
                self.nodes_to_update.insert(downstream_node_id);

                // 递归标记
                self.mark_downstream_nodes_for_update(downstream_node_id);
            }
        }
    }

    // 执行拓扑排序
    fn perform_topological_sort(&self) -> Vec<egui_node_graph::NodeId> {
        // 实现拓扑排序算法，确保节点按依赖关系顺序执行
        // 简化实现，实际应用中应使用更完善的算法
        let mut visited = std::collections::HashSet::new();
        let mut result = Vec::new();

        // 从无入度的节点开始
        for (node_id, node) in &self.graph.nodes {
            if !visited.contains(node_id) {
                self.dfs_visit(node_id, &mut visited, &mut result);
            }
        }

        result.reverse(); // 反转结果以获得正确的拓扑顺序
        result
    }

    // 深度优先遍历辅助函数
    fn dfs_visit(&self, node_id: &egui_node_graph::NodeId, visited: &mut std::collections::HashSet<egui_node_graph::NodeId>, result: &mut Vec<egui_node_graph::NodeId>) {
        visited.insert(*node_id);

        // 找到所有依赖此节点的下游节点
        for (input_id, connected_output_id) in &self.graph.connections {
            // 检查是否是当前节点的输出
            let node = &self.graph.nodes[*node_id];
            if node.outputs.values().any(|&id| id == *connected_output_id) {
                // 找到输入节点
                let input = &self.graph.inputs[*input_id];
                let downstream_node_id = input.node;

                if !visited.contains(&downstream_node_id) {
                    self.dfs_visit(&downstream_node_id, visited, result);
                }
            }
        }

        result.push(*node_id);
    }

    // 实现WidgetValueTrait以支持自定义控件
    // ...
}
```