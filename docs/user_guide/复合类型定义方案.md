# 配电系统复合类型定义方案

本文档基于`g:\04 rust\PDSD-v0.2\src\editor\business\text_switching_components.rs`中已定义的参数，详细定义了PDSD系统中使用的复合数据类型，特别是回路数据（CircuitData）和配电箱数据（DistributionBoxData）的结构和实现方案，确保参数定义与现有代码保持一致。

根据需求，以下是整理后的回路数据和配电箱数据复合类型定义方案：

## 一、回路数据复合类型 (CircuitData)

```rust
use serde::{Deserialize, Serialize};

/// 断路器类型
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum BreakerType {
    ACB,      //框架断路器
    MCCB,     // 塑壳断路器
    MCCBRCBO, //塑壳漏电断路器
    MCB,      // 微型断路器
    RCBO,     //漏电断路器
    IS,       //隔离开关
    ATS,      //双电源自动转换开关
}

impl BreakerType {
    pub fn to_str(&self) -> &'static str {
        match self {
            BreakerType::ACB => "ACB",
            BreakerType::MCCB => "MCCB",
            BreakerType::MCCBRCBO => "MCCB-RCBO",
            BreakerType::MCB => "MCB",
            BreakerType::RCBO => "RCBO",
            BreakerType::IS => "IS",
            BreakerType::ATS => "ATS-PC(CB)",
        }
    }
}

/// 壳架电流
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum FrameCurrent {
    A63,
    A100,
    A160,
    A250,
    A400,
    A630,
    A800,
}

impl FrameCurrent {
    pub fn to_str(&self) -> &'static str {
        match self {
            FrameCurrent::A63 => "63",
            FrameCurrent::A100 => "100",
            FrameCurrent::A160 => "160",
            FrameCurrent::A250 => "250",
            FrameCurrent::A400 => "400",
            FrameCurrent::A630 => "630",
            FrameCurrent::A800 => "800",
        }
    }
    
    pub fn to_f64(&self) -> f64 {
        match self {
            FrameCurrent::A63 => 63.0,
            FrameCurrent::A100 => 100.0,
            FrameCurrent::A160 => 160.0,
            FrameCurrent::A250 => 250.0,
            FrameCurrent::A400 => 400.0,
            FrameCurrent::A630 => 630.0,
            FrameCurrent::A800 => 800.0,
        }
    }
}

/// 分断能力
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum BreakingCapacity {
    F, //36kA
    N, //50kA
    H, //70kA
    S, //100kA
    L, //150kA
}

impl BreakingCapacity {
    pub fn to_str(&self) -> &'static str {
        match self {
            BreakingCapacity::F => "F",
            BreakingCapacity::N => "N",
            BreakingCapacity::H => "H",
            BreakingCapacity::S => "S",
            BreakingCapacity::L => "L",
        }
    }
}

/// 脱扣方式
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum DeductionMethod {
    TM, //热磁型
    MA, //单磁型
}

impl DeductionMethod {
    pub fn to_str(&self) -> &'static str {
        match self {
            DeductionMethod::TM => "TM",
            DeductionMethod::MA => "MA",
        }
    }
}

/// 极数
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Pole {
    P1,
    P2,
    P3,
    P4,
    P1N,
    P3N,
}

impl Pole {
    pub fn to_str(&self) -> &'static str {
        match self {
            Pole::P1 => "1P",
            Pole::P2 => "2P",
            Pole::P3 => "3P",
            Pole::P4 => "4P",
            Pole::P1N => "1P+N",
            Pole::P3N => "3P+N",
        }
    }
    
    /// 获取极数对应的数值
    pub fn to_u32(&self) -> u32 {
        match self {
            Pole::P1 => 1,
            Pole::P2 => 2,
            Pole::P3 => 3,
            Pole::P4 => 4,
            Pole::P1N => 2,
            Pole::P3N => 4,
        }
    }
}

/// 脱扣曲线
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Curve {
    B,
    C,
    D,
}

impl Curve {
    pub fn to_str(&self) -> &'static str {
        match self {
            Curve::B => "B",
            Curve::C => "C",
            Curve::D => "D",
        }
    }
}

/// 整定电流值
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SettingValue {
    A6,   //6A
    A10,  //10A
    A16,  //16A
    A20,  //20A
    A25,  //25A
    A32,  //32A
    A40,  //40A
    A50,  //50A
    A63,  //63A
    A80,  //80A
    A100, //100A
    A125, //125A
    A140, //140A
    A160, //160A
    A180, //180A
    A200, //200A
    A225, //225A
    A250, //250A
    A315, //315A
    A350, //350A
    A400, //400A
    A500, //500A
    A630, //630A
    A800, //800A
    A1000, //1000A
    A1250, //1250A
    A1600, //1600A
    A2000, //2000A
}

impl SettingValue {
    pub fn to_str(&self) -> &'static str {
        match self {
            SettingValue::A16 => "16",
            SettingValue::A20 => "20",
            SettingValue::A25 => "25",
            SettingValue::A32 => "32",
            SettingValue::A40 => "40",
            SettingValue::A50 => "50",
            SettingValue::A63 => "63",
            SettingValue::A80 => "80",
            SettingValue::A100 => "100",
            SettingValue::A125 => "125",
            SettingValue::A140 => "140",
            SettingValue::A160 => "160",
            SettingValue::A180 => "180",
            SettingValue::A200 => "200",
            SettingValue::A225 => "225",
            SettingValue::A250 => "250",
            SettingValue::A315 => "315",
            SettingValue::A350 => "350",
            SettingValue::A400 => "400",
            SettingValue::A500 => "500",
            SettingValue::A630 => "630",
            SettingValue::A800 => "800",
            SettingValue::A1000 => "1000",
        }
    }
    
    pub fn to_f64(&self) -> f64 {
        match self {
            SettingValue::A16 => 16.0,
            SettingValue::A20 => 20.0,
            SettingValue::A25 => 25.0,
            SettingValue::A32 => 32.0,
            SettingValue::A40 => 40.0,
            SettingValue::A50 => 50.0,
            SettingValue::A63 => 63.0,
            SettingValue::A80 => 80.0,
            SettingValue::A100 => 100.0,
            SettingValue::A125 => 125.0,
            SettingValue::A140 => 140.0,
            SettingValue::A160 => 160.0,
            SettingValue::A180 => 180.0,
            SettingValue::A200 => 200.0,
            SettingValue::A225 => 225.0,
            SettingValue::A250 => 250.0,
            SettingValue::A315 => 315.0,
            SettingValue::A350 => 350.0,
            SettingValue::A400 => 400.0,
            SettingValue::A500 => 500.0,
            SettingValue::A630 => 630.0,
            SettingValue::A800 => 800.0,
            SettingValue::A1000 => 1000.0,
        }
    }
}

/// 相位配置
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PhaseConfig {
    SinglePhase,        // 单相
    ThreePhase,         // 三相
    ThreePhaseFourWire, // 三相四线
}

impl Default for PhaseConfig {
    fn default() -> Self {
        PhaseConfig::ThreePhase // 默认三相
    }
}

/// 电气元器件类型枚举
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ElectricComponent {
    Breaker(CircuitBreaker),        // 断路器
    Isolator(Isolator),             // 隔离开关
    DualPowerSwitch(DualPowerSwitch), // 双电源开关
    Contactor(Contactor),           // 接触器
    EnergyMeter(EnergyMeter),       // 电能表
}

impl ElectricComponent {
    /// 获取元器件的额定电流(A)
    pub fn get_rated_current(&self) -> f64 {
        match self {
            ElectricComponent::Breaker(breaker) => breaker.rated_current.to_f64(),
            ElectricComponent::Isolator(isolator) => isolator.rated_current.to_f64(),
            ElectricComponent::DualPowerSwitch(dps) => dps.rated_current.to_f64(),
            ElectricComponent::Contactor(contactor) => contactor.rated_current.to_f64(),
            ElectricComponent::EnergyMeter(meter) => meter.rated_current.to_f64(),
        }
    }

    /// 获取元器件的型号
    pub fn get_model(&self) -> &str {
        match self {
            ElectricComponent::Breaker(breaker) => &breaker.model,
            ElectricComponent::Isolator(isolator) => &isolator.model,
            ElectricComponent::DualPowerSwitch(dps) => &dps.model,
            ElectricComponent::Contactor(contactor) => &contactor.model,
            ElectricComponent::EnergyMeter(meter) => &meter.model,
        }
    }

    /// 获取元器件的极数
    pub fn get_poles(&self) -> u32 {
        match self {
            ElectricComponent::Breaker(breaker) => breaker.pole.as_ref().map_or(1, |p| p.to_u32()),
            ElectricComponent::Isolator(isolator) => isolator.pole.to_u32(),
            ElectricComponent::DualPowerSwitch(dps) => dps.pole.to_u32(),
            ElectricComponent::Contactor(contactor) => contactor.pole.to_u32(),
            ElectricComponent::EnergyMeter(meter) => {
                meter.phase_config.as_ref().map_or(1, |pc| match pc {
                    PhaseConfig::SinglePhase => 1,
                    PhaseConfig::ThreePhase => 3,
                    PhaseConfig::ThreePhaseFourWire => 4,
                })
            },
        }
    }
}

/// 相序枚举
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Phase {
    L1,    // A相
    L2,    // B相
    L3,    // C相
    ThreePhase, // 三相(空值表示)
}

/// 断路器参数
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CircuitBreaker {
    pub breaker_type: Option<BreakerType>,      // 断路器类型
    pub model: String,                          // 断路器型号
    pub frame_current: FrameCurrent,            // 壳架电流值(A)
    pub rated_current: SettingValue,            // 整定电流值(A)
    pub pole: Option<Pole>,                     // 极数
    pub breaking_capacity: Option<BreakingCapacity>, // 分断能力
    pub curve: Option<Curve>,                   // 脱扣曲线
    pub deduction_method: Option<DeductionMethod>, // 脱扣方式
}

/// 隔离开关参数
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Isolator {
    pub model: String,                          // 隔离开关型号
    pub frame_current: FrameCurrent,            // 壳架电流值(A)
    pub rated_current: SettingValue,            // 额定电流(A)
    pub pole: Pole,                             // 极数
    pub insulation_level: f64,                  // 绝缘水平(kV)
}

/// 双电源开关参数
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DualPowerSwitch {
    pub model: String,                          // 双电源开关型号
    pub frame_current: FrameCurrent,            // 壳架电流值(A)
    pub rated_current: SettingValue,            // 额定电流(A)
    pub pole: Pole,                             // 极数
    pub breaking_capacity: Option<BreakingCapacity>, // 分断能力
    pub transfer_time: f64,                     // 切换时间(ms)
    pub operation_type: String,                 // 操作方式(自动/手动)
}

/// 接触器参数
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Contactor {
    pub model: String,                          // 接触器型号
    pub frame_current: FrameCurrent,            // 壳架电流值(A)
    pub rated_current: SettingValue,            // 额定电流(A)
    pub pole: Pole,                             // 极数
    pub control_voltage: f64,                   // 控制电压(V)
    pub breaking_capacity: Option<BreakingCapacity>, // 分断能力
}

/// 电能表参数
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EnergyMeter {
    pub model: String,                          // 电能表型号
    pub rated_current: SettingValue,            // 额定电流(A)
    pub max_current: SettingValue,              // 最大电流(A)
    pub accuracy_class: f64,                    // 精度等级
    pub communication: String,                  // 通讯方式
    pub phase_config: Option<PhaseConfig>,      // 相位配置
}


/// 线缆参数
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CableInfo {
    pub model: String,      // 线缆型号
    pub voltage_level: f64, // 电压等级(kV)
    pub size: String,       // 线缆规格(如: BV-2.5mm²)
    pub laying_method: String, // 敷设方式
    pub pipe_diameter: String, // 穿管管径
    pub is_three_phase: bool,  // 单三相判断
}

/// 回路数据复合类型
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CircuitData {
    pub circuit_id: String,         // 回路编号
    pub phase_sequence: Phase, // 相序
    pub components: Vec<ElectricComponent>, // 元器件参数列表
    pub cable: CableInfo,           // 线缆选型
    
    // 以下为电气参数
    pub rated_power: f64,           // 额定功率(kW) - 对应pe
    pub power_factor: f64,          // 功率因数 - 对应cos
    pub demand_coefficient: f64,    // 需用系数 - 对应kx
    pub calculated_current: f64,    // 计算电流(A) - 对应ijs
    
    pub circuit_type: String,       // 回路类型(照明/动力/混合)
    pub description: String,        // 回路描述
}

impl CircuitData {
    /// 添加一个元器件到回路
    pub fn add_component(&mut self, component: ElectricComponent) {
        self.components.push(component);
    }
    
    /// 查找回路中的断路器
    pub fn find_breaker(&self) -> Option<&CircuitBreaker> {
        self.components.iter().find_map(|comp| match comp {
            ElectricComponent::Breaker(breaker) => Some(breaker),
            _ => None,
        })
    }
    
    /// 查找回路中的隔离开关
    pub fn find_isolator(&self) -> Option<&Isolator> {
        self.components.iter().find_map(|comp| match comp {
            ElectricComponent::Isolator(isolator) => Some(isolator),
            _ => None,
        })
    }
    
    /// 更新回路中的断路器
    pub fn update_breaker(&mut self, breaker: CircuitBreaker) -> bool {
        if let Some(pos) = self.components.iter().position(|comp| matches!(comp, ElectricComponent::Breaker(_))) {
            self.components[pos] = ElectricComponent::Breaker(breaker);
            true
        } else {
            // 如果不存在断路器，则添加一个新的
            self.components.push(ElectricComponent::Breaker(breaker));
            true
        }
    }
    
    /// 添加或替换断路器
    pub fn set_breaker(&mut self, breaker: CircuitBreaker) {
        let _ = self.update_breaker(breaker);
    }
    
    /// 删除指定类型的元器件
    pub fn remove_component_of_type(&mut self, component_type: &str) {
        self.components.retain(|comp| {
            let comp_type_str = match comp {
                ElectricComponent::Breaker(_) => "breaker",
                ElectricComponent::Isolator(_) => "isolator",
                ElectricComponent::DualPowerSwitch(_) => "dual_power_switch",
                ElectricComponent::Contactor(_) => "contactor",
                ElectricComponent::EnergyMeter(_) => "energy_meter",
            };
            comp_type_str != component_type.to_lowercase()
        });
    }
}

// 实现默认值
impl Default for CircuitBreaker {
    fn default() -> Self {
        Self {
            breaker_type: Some(BreakerType::MCCB),
            model: "NSX100N".to_string(),
            frame_current: FrameCurrent::A100,
            rated_current: SettingValue::A63,
            pole: Some(Pole::P3),
            breaking_capacity: Some(BreakingCapacity::N),
            curve: Some(Curve::C),
            deduction_method: Some(DeductionMethod::TM),
        }
    }
}

impl Default for Isolator {
    fn default() -> Self {
        Self {
            model: "GL-100".to_string(),
            frame_current: FrameCurrent::A100,
            rated_current: SettingValue::A100,
            pole: Pole::P3,
            insulation_level: 0.69,
        }
    }
}

impl Default for DualPowerSwitch {
    fn default() -> Self {
        Self {
            model: "ATSE-100".to_string(),
            frame_current: FrameCurrent::A100,
            rated_current: SettingValue::A100,
            pole: Pole::P4,
            breaking_capacity: Some(BreakingCapacity::N),
            transfer_time: 100.0,
            operation_type: "自动".to_string(),
        }
    }
}

impl Default for Contactor {
    fn default() -> Self {
        Self {
            model: "LC1-D12".to_string(),
            frame_current: FrameCurrent::A25,
            rated_current: SettingValue::A12,
            pole: Pole::P3,
            control_voltage: 220.0,
            breaking_capacity: Some(BreakingCapacity::N),
        }
    }
}

impl Default for EnergyMeter {
    fn default() -> Self {
        Self {
            model: "DTZ541".to_string(),
            rated_current: SettingValue::A5,
            max_current: SettingValue::A60,
            accuracy_class: 0.5,
            communication: "RS485".to_string(),
            phase_config: Some(PhaseConfig::ThreePhase),
        }
    }
}

impl Default for CableInfo {
    fn default() -> Self {
        Self {
            model: "BV".to_string(),
            voltage_level: 0.45,
            size: "2.5mm²".to_string(),
            laying_method: "穿管暗敷".to_string(),
            pipe_diameter: "φ20".to_string(),
            is_three_phase: false,
        }
    }
}

impl Default for CircuitData {
    fn default() -> Self {
        Self {
            circuit_id: "001".to_string(),
            phase_sequence: Phase::L1,
            components: vec![ElectricComponent::Breaker(CircuitBreaker::default())],
            cable: CableInfo::default(),
            rated_power: 1.0,
            power_factor: 0.8,
            demand_coefficient: 0.8,
            calculated_current: 0.0,
            circuit_type: "照明".to_string(),
            description: "".to_string(),
        }
    }
}
```

## 二、配电箱数据复合类型 (DistributionBoxData)

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// 配电箱数据复合类型
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DistributionBoxData {
    pub box_id: String,             // 配电箱编号
    pub name: String,               // 配电箱名称
    pub box_type: String,           // 配电箱类型
    
    // 回路节点集合
    pub circuits: HashMap<String, CircuitData>, // 回路节点，键为回路编号
    
    // 进线参数
    pub incoming_components: Vec<ElectricComponent>, // 进线元器件参数列表
    pub incoming_wire_size: String,       // 进线规格
    
    // 电气参数
    pub rated_power: f64,           // 额定功率(kW) - 对应pe
    pub demand_coefficient: f64,    // 需用系数 - 对应kx
    pub power_factor: f64,          // 功率因数 - 对应cos
    pub calculated_current: f64,    // 计算电流(A) - 对应ijs
    pub rated_voltage: f64,         // 额定电压(V)
    
    // 三相负载分布
    pub phase_a_load: f64,          // A相负载(kW)
    pub phase_b_load: f64,          // B相负载(kW)
    pub phase_c_load: f64,          // C相负载(kW)
    
    pub description: String,        // 配电箱描述
}

// 实现默认值
impl Default for DistributionBoxData {
    fn default() -> Self {
        Self {
            box_id: "MDB-001".to_string(),
            name: "照明配电箱".to_string(),
            box_type: "户内嵌入式".to_string(),
            circuits: HashMap::new(),
            incoming_components: vec![
                ElectricComponent::CircuitBreaker(CircuitBreaker {
                    model: "CM1-225".to_string(),
                    frame_current: 225.0,
                    rated_current: 100.0,
                    poles: 3,
                    breaking_capacity: 50.0,
                    trip_type: "D".to_string(),
                }),
                ElectricComponent::EnergyMeter(EnergyMeter::default()),
            ],
            incoming_wire_size: "BV-4×25+1×16mm²".to_string(),
            rated_power: 0.0,
            demand_coefficient: 0.9,
            power_factor: 0.85,
            calculated_current: 0.0,
            rated_voltage: 380.0,
            phase_a_load: 0.0,
            phase_b_load: 0.0,
            phase_c_load: 0.0,
            description: "".to_string(),
        }
    }
}

// 为配电箱数据提供自动分配回路编号的方法
impl DistributionBoxData {
    /// 根据负载电流自动计算整定值
    pub fn compute_setting_value(load_current: f64) -> SettingValue {
        // 整定值必须大于负载电流（1.25倍安全系数）
        let required_current = load_current * 1.25;

        // 查找最接近的标准整定值
        let setting_values = [
            SettingValue::A16,
            SettingValue::A20,
            SettingValue::A25,
            SettingValue::A32,
            SettingValue::A40,
            SettingValue::A50,
            SettingValue::A63,
            SettingValue::A80,
            SettingValue::A100,
            SettingValue::A125,
            SettingValue::A140,
            SettingValue::A160,
            SettingValue::A180,
            SettingValue::A200,
            SettingValue::A225,
            SettingValue::A250,
            SettingValue::A315,
            SettingValue::A350,
            SettingValue::A400,
            SettingValue::A500,
            SettingValue::A630,
            SettingValue::A800,
            SettingValue::A1000,
        ];

        // 返回第一个大于等于所需电流的标准值
        setting_values
            .into_iter()
            .find(|&sv| sv.to_f64() >= required_current)
            .unwrap_or(SettingValue::A1000) // 默认最大整定值
    }

    /// 根据连接的回路节点数量自动分配回路编号
    pub fn assign_circuit_ids(&mut self) {
        // 获取当前回路数量，按数量排序后重新分配编号
        let mut circuits_vec: Vec<_> = self.circuits.iter().collect();
        
        // 清空现有回路
        let circuits_data: Vec<_> = circuits_vec.drain(..).map(|(_, data)| data.clone()).collect();
        self.circuits.clear();
        
        // 按排序后的顺序重新分配编号
        for (i, circuit) in circuits_data.iter().enumerate() {
            let new_id = format!("{:03}", i + 1); // 格式化为三位数编号
            let mut new_circuit = circuit.clone();
            new_circuit.circuit_id = new_id.clone();
            self.circuits.insert(new_id, new_circuit);
        }
    }
    
    /// 添加新的回路到配电箱
    pub fn add_circuit(&mut self, mut circuit: CircuitData) {
        // 添加回路
        let circuit_id = format!("{:03}", self.circuits.len() + 1); // 自动生成编号
        circuit.circuit_id = circuit_id.clone();
        self.circuits.insert(circuit_id, circuit);
        
        // 重新计算总功率和三相负载
        self.recalculate_parameters();
    }
    
    /// 为回路添加元器件
    pub fn add_component_to_circuit(&mut self, circuit_id: &str, component: ElectricComponent) {
        if let Some(circuit) = self.circuits.get_mut(circuit_id) {
            circuit.components.push(component);
        }
    }
    
    /// 获取回路的断路器参数
    pub fn get_circuit_breaker(&self, circuit_id: &str) -> Option<&CircuitBreaker> {
        self.circuits.get(circuit_id).and_then(|circuit| {
            circuit.components.iter()
                .find_map(|component| {
                    if let ElectricComponent::CircuitBreaker(breaker) = component {
                        Some(breaker)
                    } else {
                        None
                    }
                })
        })
    }
    
    /// 获取进线断路器参数
    pub fn get_incoming_breaker(&self) -> Option<&CircuitBreaker> {
        self.incoming_components.iter()
            .find_map(|component| {
                if let ElectricComponent::CircuitBreaker(breaker) = component {
                    Some(breaker)
                } else {
                    None
                }
            })
    }
    
    /// 移除指定回路
    pub fn remove_circuit(&mut self, circuit_id: &str) {
        if self.circuits.remove(circuit_id).is_some() {
            // 重新分配回路编号
            self.assign_circuit_ids();
            // 重新计算参数
            self.recalculate_parameters();
        }
    }
    
    /// 重新计算配电箱的电气参数
    fn recalculate_parameters(&mut self) {
        self.rated_power = 0.0;
        self.phase_a_load = 0.0;
        self.phase_b_load = 0.0;
        self.phase_c_load = 0.0;
        
        // 计算各相负载和总功率
        for circuit in self.circuits.values() {
            let effective_power = circuit.rated_power * circuit.demand_coefficient;
            
            match circuit.phase_sequence {
                Phase::L1 => {
                    self.phase_a_load += effective_power;
                },
                Phase::L2 => {
                    self.phase_b_load += effective_power;
                },
                Phase::L3 => {
                    self.phase_c_load += effective_power;
                },
                Phase::ThreePhase => {
                    let phase_power = effective_power / 3.0;
                    self.phase_a_load += phase_power;
                    self.phase_b_load += phase_power;
                    self.phase_c_load += phase_power;
                }
            }
            
            self.rated_power += effective_power;
        }
        
        // 计算计算电流(使用三相电流计算公式)
        if self.rated_power > 0.0 {
            const U: f64 = 0.38; // 额定电压(kV)
            let sqrt3: f64 = 3.0_f64.sqrt();
            self.calculated_current = self.rated_power / U / self.power_factor / sqrt3;
        } else {
            self.calculated_current = 0.0;
        }
    }
    
    /// 为进线添加元器件
    pub fn add_main_component(&mut self, component: ElectricComponent) {
        self.incoming_components.push(component);
    }
    
    /// 查找进线断路器
    pub fn find_main_breaker(&self) -> Option<&CircuitBreaker> {
        self.incoming_components.iter().find_map(|comp| match comp {
            ElectricComponent::Breaker(breaker) => Some(breaker),
            _ => None,
        })
    }
    
    /// 更新进线断路器
    pub fn update_main_breaker(&mut self, breaker: CircuitBreaker) -> bool {
        if let Some(pos) = self.incoming_components.iter().position(|comp| matches!(comp, ElectricComponent::Breaker(_))) {
            self.incoming_components[pos] = ElectricComponent::Breaker(breaker);
            true
        } else {
            // 如果不存在断路器，则添加一个新的
            self.incoming_components.push(ElectricComponent::Breaker(breaker));
            true
        }
    }
    
    /// 根据回路编号查找回路
    pub fn find_circuit_by_id(&self, circuit_id: &str) -> Option<&CircuitData> {
        self.circuits.get(circuit_id)
    }
    
    /// 根据回路编号查找并修改回路
    pub fn update_circuit_by_id(&mut self, circuit_id: &str, mut update_fn: impl FnMut(&mut CircuitData)) -> bool {
        if let Some(circuit) = self.circuits.get_mut(circuit_id) {
            update_fn(circuit);
            true
        } else {
            false
        }
    }
    
    /// 获取三相平衡度
    pub fn get_balance_degree(&self) -> f64 {
        let max_phase = self.phase_a_load.max(self.phase_b_load).max(self.phase_c_load);
        let min_phase = self.phase_a_load.min(self.phase_b_load).min(self.phase_c_load);
        
        if max_phase == 0.0 {
            return 0.0;
        }
        
        ((max_phase - min_phase) / max_phase) * 100.0
    }
}
```

## 三、与现有ElectricValueType的集成方案

```rust
// 修改ElectricValueType枚举以使用新的复合类型
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ElectricValueType {
    Float(f64),              // 用于电流、功率等数值
    Integer(i64),            // 用于整数标识
    String(String),          // 用于型号、名称等文本
    CircuitData(CircuitData), // 配电回路数据
    DistributionBoxData(DistributionBoxData), // 配电箱数据
    ThreePhaseData(PhaseBalanceInfo), // 三相数据
}

// 修改ElectricValueType的相关方法
impl ElectricValueType {
    /// 获取回路数据
    pub fn as_circuit_data(&self) -> Option<&CircuitData> {
        match self {
            ElectricValueType::CircuitData(data) => Some(data),
            _ => None,
        }
    }
    
    /// 获取配电箱数据
    pub fn as_distribution_box_data(&self) -> Option<&DistributionBoxData> {
        match self {
            ElectricValueType::DistributionBoxData(data) => Some(data),
            _ => None,
        }
    }
    
    // 其他方法保持不变
}
```

## 四、注意事项

1. **参数映射关系**：
   - pe 对应 rated_power
   - kx 对应 demand_coefficient
   - cos 对应 power_factor
   - ijs 对应 calculated_current

2. **类型一致性**：新定义的复合类型均实现了Serialize和Deserialize特性，确保可以正常序列化和反序列化。

3. **扩展性**：设计中充分考虑了未来可能的业务扩展需求，如回路类型、敷设方式等字段使用了字符串类型而非枚举。

4. **自动化功能**：配电箱数据类型提供了自动分配回路编号、添加/移除回路、重新计算参数等便捷方法。

5. **与现有代码的兼容性**：新定义的复合类型可以无缝集成到现有的ElectricValueType中，只需对相关代码进行适配。