配电箱节点负责管理多个配电回路节点，实现自动编号和三相平衡功能：

```rust
// 定义配电箱节点数据结构
#[derive(Debug, Clone)]
struct DistributionBoxNodeData {
    node_type: MyAppNodeType,
    name: String,          // 配电箱名称
    total_power: f64,      // 总功率
    total_current: f64,    // 总电流
    incoming_current: f64, // 进线保护设备电流整定值
    floor: u32,            // 所在楼层
    modules: Vec<String>,  // 包含的模块 (能耗监测、电气火灾监测等)
    phase_loads: [f64; 3], // L1, L2, L3各相负载
}

impl DistributionBoxNodeData {
    // 自动编号功能
    fn auto_number_circuits(&self, circuit_nodes: &mut [CircuitNodeData]) {
        // 按功率大小或其他规则对回路进行排序
        // 然后依次分配编号
        let mut sorted_indices: Vec<usize> = (0..circuit_nodes.len()).collect();
        sorted_indices.sort_by(|&i, &j| {
            circuit_nodes[i].power.partial_cmp(&circuit_nodes[j].power).unwrap_or(std::cmp::Ordering::Equal)
        });

        // 分配编号
        for (idx, &original_idx) in sorted_indices.iter().enumerate() {
            circuit_nodes[original_idx].circuit_number = (idx + 1) as u32;
        }
    }

    // 三相平衡算法
    fn balance_three_phases(&mut self, circuit_nodes: &mut [CircuitNodeData]) {
        // 1. 初始化分配：将回路按顺序分配到各相
        let phases = ['L', '1', '2', '3'];
        for (i, circuit) in circuit_nodes.iter_mut().enumerate() {
            let phase_idx = i % 3;
            circuit.phase = Some(phases[phase_idx + 1]);
            self.phase_loads[phase_idx] += circuit.power;
        }

        // 2. 迭代优化平衡
        let mut iterations = 0;
        let max_iterations = 100;
        let tolerance = 0.01; // 允许的不平衡度

        while iterations < max_iterations {
            let total_power: f64 = self.phase_loads.iter().sum();
            let avg_power = total_power / 3.0;

            // 检查是否已平衡
            let max_diff = self.phase_loads.iter().map(|&p| (p - avg_power).abs()).fold(0.0, f64::max);
            if max_diff / avg_power < tolerance {
                break;
            }

            // 找到负载最大的相和最小的相
            let mut max_phase = 0;
            let mut min_phase = 0;

            for i in 1..3 {
                if self.phase_loads[i] > self.phase_loads[max_phase] {
                    max_phase = i;
                }
                if self.phase_loads[i] < self.phase_loads[min_phase] {
                    min_phase = i;
                }
            }

            // 从最大负载相转移一个回路到最小负载相
            if let Some((circuit_idx, _)) = circuit_nodes
                .iter()
                .enumerate()
                .filter(|(_, c)| c.phase == Some(phases[max_phase + 1]))
                .find(|(_, c)| {
                    // 尝试转移后，最大负载相仍大于最小负载相
                    let new_max = self.phase_loads[max_phase] - c.power;
                    let new_min = self.phase_loads[min_phase] + c.power;
                    new_max >= new_min
                })
                .next()
            {
                let circuit = &mut circuit_nodes[circuit_idx];
                self.phase_loads[max_phase] -= circuit.power;
                self.phase_loads[min_phase] += circuit.power;
                circuit.phase = Some(phases[min_phase + 1]);
            }

            iterations += 1;
        }
    }

    // 计算总功率和电流
    fn calculate_total_power(&mut self, circuit_nodes: &[CircuitNodeData]) {
        self.total_power = circuit_nodes.iter().map(|c| c.power).sum();

        // 计算总电流 (假设三相380V，功率因数0.85)
        self.total_current = self.total_power * 1000.0 / (1.732 * 380.0 * 0.85);

        // 确定进线保护设备电流整定值
        self.calculate_incoming_current();
    }

    // 计算进线保护设备电流整定值
    fn calculate_incoming_current(&mut self) {
        // 根据总电流和规范要求确定进线保护设备电流整定值
        let standard_values = [100, 125, 160, 200, 250, 315, 400, 500, 630];

        // 进线电流通常考虑1.2倍的安全系数
        let required_current = self.total_current * 1.2;

        for &value in &standard_values {
            if value as f64 >= required_current {
                self.incoming_current = value as f64;
                return;
            }
        }

        self.incoming_current = 630.0; // 默认值
    }
}
```