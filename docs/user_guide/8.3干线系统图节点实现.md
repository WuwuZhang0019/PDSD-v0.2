干线系统图节点负责自动生成配电干线图和各种监测系统图：

```rust
// 定义干线系统图类型
enum MainSystemType {
    PowerDistribution,     // 配电干线图
    EnergyMonitoring,      // 能耗监测干线图
    ElectricalFireMonitoring, // 电气火灾监控干线图
    FirePowerMonitoring,   // 消防电源监测干线图
}

// 定义干线系统图节点数据结构
#[derive(Debug, Clone)]
struct MainSystemNodeData {
    node_type: MyAppNodeType,
    systems: Vec<MainSystemType>, // 包含的系统图类型
    auto_layout: bool,           // 是否自动布局
}

impl MainSystemNodeData {
    // 自动映射功能
    fn auto_map_distribution_boxes(&self, boxes: &[DistributionBoxNodeData]) -> Vec<SystemDiagram> {
        let mut diagrams = Vec::new();

        // 按楼层对配电箱进行分组
        let mut boxes_by_floor: std::collections::BTreeMap<u32, Vec<&DistributionBoxNodeData>> = std::collections::BTreeMap::new();
        for box_node in boxes {
            boxes_by_floor.entry(box_node.floor).or_default().push(box_node);
        }

        // 生成各类系统图
        for &system_type in &self.systems {
            match system_type {
                MainSystemType::PowerDistribution => {
                    let diagram = self.generate_power_distribution_diagram(&boxes_by_floor);
                    diagrams.push(diagram);
                },
                MainSystemType::EnergyMonitoring => {
                    // 只包含有能耗监测模块的配电箱
                    let filtered_boxes: std::collections::BTreeMap<u32, Vec<&DistributionBoxNodeData>> = boxes_by_floor
                        .iter()
                        .filter(|(_, floor_boxes)| {
                            floor_boxes.iter().any(|b| b.modules.contains(&"能耗监测".to_string()))
                        })
                        .map(|(&floor, boxes)| (floor, boxes.clone()))
                        .collect();

                    let diagram = self.generate_energy_monitoring_diagram(&filtered_boxes);
                    diagrams.push(diagram);
                },
                MainSystemType::ElectricalFireMonitoring => {
                    // 类似能耗监测图生成...
                },
                MainSystemType::FirePowerMonitoring => {
                    // 类似能耗监测图生成...
                },
            }
        }

        diagrams
    }

    // 生成配电干线系统图
    fn generate_power_distribution_diagram(&self, boxes_by_floor: &std::collections::BTreeMap<u32, Vec<&DistributionBoxNodeData>>) -> SystemDiagram {
        let mut diagram = SystemDiagram::new("配电干线系统图".to_string());

        // 创建母线
        let busbar = diagram.add_component(ComponentType::Busbar, "主母线".to_string());

        // 按楼层自下而上添加配电箱
        let mut last_component = busbar;
        for (floor, boxes) in boxes_by_floor.iter().rev() {
            for box_node in boxes {
                let box_component = diagram.add_component(
                    ComponentType::DistributionBox,
                    format!("{}\n楼层:{}\n功率:{:.2}kW\n电流:{:.2}A",
                            box_node.name, floor, box_node.total_power, box_node.incoming_current)
                );

                // 添加连线
                diagram.add_connection(last_component, box_component);

                // 判断进线类型并生成相应的连线
                let connection_type = if box_node.modules.contains(&"双电源切换".to_string()) {
                    ConnectionType::DualPower
                } else {
                    ConnectionType::SinglePower
                };

                diagram.set_connection_type(last_component, box_component, connection_type);
            }
        }

        if self.auto_layout {
            self.auto_layout_diagram(&mut diagram);
        }

        diagram
    }

    // 自动布局算法
    fn auto_layout_diagram(&self, diagram: &mut SystemDiagram) {
        // 实现干线系统图的自动布局算法
        // 这里简化处理，实际应用中应根据图论算法进行优化布局
    }
}

// 系统图数据结构
struct SystemDiagram {
    name: String,
    components: Vec<DiagramComponent>,
    connections: Vec<DiagramConnection>,
}

enum ComponentType {
    Busbar,
    DistributionBox,
    MonitoringModule,
    // 其他组件类型...
}

enum ConnectionType {
    SinglePower,
    DualPower,
    Monitoring,
    // 其他连接类型...
}

struct DiagramComponent {
    id: usize,
    component_type: ComponentType,
    label: String,
    position: (f64, f64),
}

struct DiagramConnection {
    from: usize,
    to: usize,
    connection_type: ConnectionType,
}

impl SystemDiagram {
    fn new(name: String) -> Self {
        Self {
            name,
            components: Vec::new(),
            connections: Vec::new(),
        }
    }

    fn add_component(&mut self, component_type: ComponentType, label: String) -> usize {
        let id = self.components.len();
        self.components.push(DiagramComponent {
            id,
            component_type,
            label,
            position: (0.0, 0.0), // 初始位置，自动布局时会更新
        });
        id
    }

    fn add_connection(&mut self, from: usize, to: usize) {
        self.connections.push(DiagramConnection {
            from,
            to,
            connection_type: ConnectionType::SinglePower, // 默认连接类型
        });
    }

    fn set_connection_type(&mut self, from: usize, to: usize, connection_type: ConnectionType) {
        for connection in &mut self.connections {
            if connection.from == from && connection.to == to {
                connection.connection_type = connection_type;
                break;
            }
        }
    }
}
```