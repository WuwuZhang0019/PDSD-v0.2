
这是一个复杂但关键的部分，实现图的实际执行逻辑：

```rust
impl ElectricNodeGraphApp {
    // 构建拓扑排序以确定节点执行顺序
    fn topological_sort(&self) -> Vec<egui_node_graph::NodeId> {
        let mut visited = std::collections::HashSet::new();
        let mut result = Vec::new();

        // 从没有输入的节点开始（通常是输入节点）
        for node_id in self.graph.nodes.keys() {
            if !visited.contains(&node_id) && self.is_node_independent(node_id) {
                self.dfs_visit(node_id, &mut visited, &mut result);
            }
        }

        // 确保所有节点都被访问
        for node_id in self.graph.nodes.keys() {
            if !visited.contains(&node_id) {
                self.dfs_visit(node_id, &mut visited, &mut result);
            }
        }

        result
    }

    // 深度优先搜索访问节点
    fn dfs_visit(
        &self,
        node_id: egui_node_graph::NodeId,
        visited: &mut std::collections::HashSet<egui_node_graph::NodeId>,
        result: &mut Vec<egui_node_graph::NodeId>,
    ) {
        visited.insert(node_id);

        // 找到所有依赖当前节点的节点
        for (_, output_id) in &self.graph.nodes[node_id].outputs {
            // 找到连接到这个输出的所有输入
            for (input_id, connected_output_id) in &self.graph.connections {
                if connected_output_id == output_id {
                    // 找到输入所属的节点
                    let input_node_id = self.graph.inputs[input_id].node;
                    if !visited.contains(&input_node_id) {
                        self.dfs_visit(input_node_id, visited, result);
                    }
                }
            }
        }

        // 将当前节点添加到结果中（后序遍历确保依赖节点先执行）
        result.push(node_id);
    }

    // 判断节点是否没有依赖（独立节点）
    fn is_node_independent(&self, node_id: egui_node_graph::NodeId) -> bool {
        // 检查节点的所有输入参数
        for (_, input_id) in &self.graph.nodes[node_id].inputs {
            // 如果有任何一个输入被连接，则节点不是独立的
            if self.graph.connections.contains_key(input_id) {
                return false;
            }
        }
        true
    }

    // 获取节点输入参数的值
    fn get_input_value(
        &self,
        input_id: egui_node_graph::InputId,
    ) -> Option<MyAppValueType> {
        // 首先检查是否有连接
        if let Some(output_id) = self.graph.connections.get(input_id) {
            // 如果有连接，需要找到对应的输出节点并获取其计算结果
            // 这里简化处理，实际应用中应该缓存计算结果
            let output_param = &self.graph.outputs[*output_id];

            // 找到输出所属的节点
            let output_node_id = self.find_node_by_output(*output_id)?;
            let node_data = &self.graph.nodes[output_node_id];

            // 根据节点类型和输出索引计算结果
            // 这是一个简化的示例，实际应用中应该有更复杂的逻辑
            // let result = self.calculate_node_output(output_node_id, output_id);
            // return Some(result);

            // 由于计算可能很复杂，这里返回一个默认值作为示例
            return match output_param.typ {
                MyAppDataType::Float => Some(MyAppValueType::Float(0.0)),
                MyAppDataType::Integer => Some(MyAppValueType::Integer(0)),
                MyAppDataType::Boolean => Some(MyAppValueType::Boolean(false)),
                _ => None,
            };
        } else {
            // 如果没有连接，返回输入参数的默认值
            let input_param = &self.graph.inputs[input_id];
            match input_param.kind {
                egui_node_graph::InputParamKind::Constant |
                egui_node_graph::InputParamKind::ConnectionOrConstant => {
                    Some(input_param.value.clone())
                },
                _ => None,
            }
        }
    }

    // 根据输出ID查找对应的节点
    fn find_node_by_output(&self, output_id: egui_node_graph::OutputId) -> Option<egui_node_graph::NodeId> {
        for (node_id, node) in &self.graph.nodes {
            for (_, out_id) in &node.outputs {
                if *out_id == output_id {
                    return Some(node_id);
                }
            }
        }
        None
    }
}
```
          
《PDSD 项目开发指南.md》中431-551行所提及的执行引擎是电气节点图应用的核心计算组件，其具体功能和作用如下：

1. **节点执行顺序确定**：
   - 通过`topological_sort`方法实现拓扑排序算法，确保节点按照依赖关系正确执行
   - 先从无依赖的独立节点开始，再处理有依赖的节点，避免计算错误

2. **依赖关系管理**：
   - `is_node_independent`方法检测节点是否独立（无输入连接），为拓扑排序提供起点
   - `dfs_visit`方法通过深度优先搜索遍历整个图结构，确保所有依赖关系被正确处理

3. **数据流动控制**：
   - 实现了基于有向图的节点间数据传输机制
   - `find_node_by_output`方法支持通过输出ID追踪到对应的输出节点，建立数据溯源

4. **参数值获取机制**：
   - `get_input_value`方法智能处理节点输入参数的取值逻辑
   - 优先从连接的上游节点获取计算结果
   - 若无连接则使用参数的默认值
   - 支持不同数据类型（Float、Integer、Boolean等）的处理

5. **计算框架基础**：
   - 提供了计算结果缓存的扩展接口（注释中提及）
   - 预留了针对不同节点类型的专用计算方法接口
   - 为复杂电气系统的计算分析提供了可扩展的执行框架

这个执行引擎通过拓扑排序算法和依赖图分析，确保电气系统图中的所有节点按照正确的依赖顺序执行计算，是整个电气配电系统设计工具的核心计算引擎。
        