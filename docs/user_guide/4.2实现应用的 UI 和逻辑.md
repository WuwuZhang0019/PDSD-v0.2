### 4.2 实现电气系统应用的 UI 和逻辑（update 方法）

```rust
use eframe::egui;
use eframe::{App, Frame};

impl eframe::App for ElectricNodeGraphApp {
    fn update(&mut self, ctx: &egui::Context, frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            // 创建应用标题和项目信息
            ui.horizontal(|ui| {
                ui.label(egui::RichText::new(format!("{} - 项目ID: {}", self.project_name, self.project_id.to_string().split('-').next().unwrap())).heading().color(egui::Color32::from_rgb(0, 100, 200)));
                if ui.button("项目设置").clicked() {
                    // 打开项目设置对话框
                    self.open_project_settings(ui);
                }
            });
            ui.separator();

            // 创建工具栏
            ui.horizontal(|ui| {
                // 添加节点按钮
                if ui.button("添加节点").clicked() {
                    // 创建上下文菜单显示可用节点类型，按类别分组
                    ui.menu_button("选择节点类型", |ui| {
                        // 按类别组织节点模板
                        let templates = all_electric_templates();

                        // 收集所有唯一类别
                        let mut categories = std::collections::HashSet::new();
                        for template in &templates {
                            categories.insert(template.category().to_string());
                        }

                        // 按类别显示节点
                        for category in categories.into_iter() {
                            ui.menu_button(category, |ui| {
                                for template in &templates {
                                    if template.category() == category {
                                        if ui.button(template.node_label()).clicked() {
                                            // 添加新节点
                                            let _ = self.graph.add_node(
                                                template.node_label(),
                                                template.user_data(),
                                                |graph, node_id| template.build_node(graph, &mut (), node_id),
                                            );
                                            ui.close_menu();
                                        }
                                    }
                                }
                            });
                        }
                    });
                }

                // 保存和加载按钮
                if ui.button("保存项目").clicked() {
                    // 实现项目保存功能
                    if let Err(e) = self.save_project() {
                        self.error_message = Some(format!("保存失败: {}", e));
                    } else {
                        self.error_message = Some("项目保存成功".to_string());
                    }
                }

                if ui.button("加载项目").clicked() {
                    // 实现项目加载功能
                    if let Err(e) = self.load_project() {
                        self.error_message = Some(format!("加载失败: {}", e));
                    } else {
                        self.error_message = Some("项目加载成功".to_string());
                    }
                }

                // 运行计算按钮
                if ui.button("运行计算").clicked() {
                    self.run_calculations();
                    self.error_message = Some("计算完成".to_string());
                }

                // 生成报告按钮
                if ui.button("生成报告").clicked() {
                    if let Err(e) = self.generate_report() {
                        self.error_message = Some(format!("报告生成失败: {}", e));
                    } else {
                        self.error_message = Some("报告生成成功".to_string());
                    }
                }
            });

            // 显示错误信息
            if let Some(error_msg) = &self.error_message {
                ui.label(egui::RichText::new(error_msg).color(egui::Color32::RED));
                // 清除错误信息计时器
                ui.ctx().request_repaint_after(std::time::Duration::from_secs(3));
                if ui.button("×").clicked() {
                    self.error_message = None;
                }
            }

            // 创建一个可滚动区域
            egui::ScrollArea::both().show(ui, |ui| {
                // 调整容器大小
                let (_id, response) = ui.allocate_space(egui::Vec2::new(
                    ui.available_width(),
                    ui.available_height() - 50.0, // 留出状态栏空间
                ));

                // 绘制节点图编辑器
                let node_responses = egui_node_graph::draw_graph_editor(
                    ui,
                    &mut self.graph,
                    &mut self.editor_state,
                    response.rect,
                    &all_electric_templates(),
                    &mut (), // 用户状态
                );

                // 处理节点响应事件
                self.handle_node_responses(node_responses);
            });

            // 状态栏显示
            ui.separator();
            ui.horizontal(|ui| {
                ui.label(format!("节点数量: {}", self.graph.nodes.len()));
                ui.label(format!("连接数量: {}", self.graph.connections.len()));
                ui.label(format!("计算缓存: {}", self.calculation_cache.len()));
            });
        });
    }
}

impl ElectricNodeGraphApp {
    // 保存项目
    fn save_project(&self) -> Result<(), Box<dyn std::error::Error>> {
        // 创建项目数据结构
        let project_data = ElectricProjectData {
            project_name: self.project_name.clone(),
            project_id: self.project_id,
            graph: &self.graph,
            calculation_cache: self.calculation_cache.clone(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            save_date: chrono::Utc::now(),
        };

        // 序列化并保存到文件
        let json_data = serde_json::to_string_pretty(&project_data)?;
        let file_path = format!("{}_{}.json",
            self.project_name.replace(' ', '_'),
            chrono::Utc::now().format("%Y%m%d_%H%M%S"));
        std::fs::write(file_path, json_data)?;

        Ok(())
    }

    // 加载项目
    fn load_project(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // 这里应该使用文件选择对话框，但为简化示例，直接读取
        // 在实际应用中，应使用文件对话框库如rfd或native-dialog
        let file_path = "电气配电系统项目.json";

        let json_data = std::fs::read_to_string(file_path)?;
        let project_data: ElectricProjectData = serde_json::from_str(&json_data)?;

        // 恢复项目数据
        self.project_name = project_data.project_name;
        self.project_id = project_data.project_id;
        self.graph = project_data.graph;
        self.calculation_cache = project_data.calculation_cache;

        Ok(())
    }

    // 运行电气系统计算
    fn run_calculations(&mut self) {
        // 1. 构建依赖图并确定计算顺序（拓扑排序）
        let execution_order = self.determine_calculation_order();

        // 2. 清除计算缓存
        self.calculation_cache.clear();

        // 3. 按照计算顺序执行每个节点
        for node_id in execution_order {
            self.calculate_node(node_id);
        }

        // 4. 计算三相平衡
        self.calculate_phase_balance();

        // 5. 更新所有节点的显示数据
        self.update_node_display_data();
    }

    // 生成报告
    fn generate_report(&self) -> Result<(), Box<dyn std::error::Error>> {
        // 创建报告生成器
        let mut report = ElectricSystemReport::new(&self.project_name, self.project_id);

        // 添加系统概览
        report.add_system_overview(&self.graph);

        // 添加节点详情
        report.add_nodes_details(&self.graph);

        // 添加计算结果
        report.add_calculation_results(&self.calculation_cache);

        // 添加三相平衡分析
        report.add_phase_balance_analysis(&self.graph);

        // 添加推荐建议
        report.add_recommendations(&self.graph, &self.calculation_cache);

        // 生成PDF报告
        let file_path = format!("报告_{}_{}.pdf",
            self.project_name.replace(' ', '_'),
            chrono::Utc::now().format("%Y%m%d_%H%M%S"));
        report.generate_pdf(&file_path)?;

        Ok(())
    }

    // 打开项目设置对话框
    fn open_project_settings(&mut self, ui: &mut egui::Ui) {
        // 这里可以实现项目设置对话框
        // 例如修改项目名称、项目参数等
    }

    // 确定计算顺序（拓扑排序）
    fn determine_calculation_order(&self) -> Vec<egui_node_graph::NodeId> {
        // 实现拓扑排序算法确定节点计算顺序
        // 从电源节点开始，依次计算下游节点
        let mut order = Vec::new();
        let mut visited = std::collections::HashSet::new();

        // 实现简化版拓扑排序
        for node_id in self.graph.nodes.keys() {
            self.traverse_node(node_id, &mut visited, &mut order);
        }

        order
    }

    // 遍历节点进行拓扑排序
    fn traverse_node(&self, node_id: egui_node_graph::NodeId, visited: &mut std::collections::HashSet<egui_node_graph::NodeId>, order: &mut Vec<egui_node_graph::NodeId>) {
        if visited.contains(&node_id) {
            return;
        }

        // 先访问所有依赖的上游节点
        // 这里需要实现依赖关系分析

        // 然后将当前节点加入顺序
        visited.insert(node_id);
        order.push(node_id);
    }

    // 计算单个节点
    fn calculate_node(&mut self, node_id: egui_node_graph::NodeId) {
        // 根据节点类型执行特定计算
        if let Some(node) = self.graph.nodes.get(node_id) {
            match &node.user_data.node_type {
                ElectricNodeType::CircuitNode => self.calculate_circuit_node(node_id, node),
                ElectricNodeType::DistributionBoxNode => self.calculate_distribution_box_node(node_id, node),
                ElectricNodeType::MainLineNode => self.calculate_main_line_node(node_id, node),
                ElectricNodeType::PowerSourceNode => self.calculate_power_source_node(node_id, node),
                _ => {}
            }
        }
    }

    // 计算配电回路节点
    fn calculate_circuit_node(&mut self, node_id: egui_node_graph::NodeId, node: &egui_node_graph::Node<ElectricNodeData, ElectricDataType, ElectricValueType>) {
        if let ElectricNodeSpecificData::Circuit(circuit_info) = &node.user_data.specific_data {
            // 根据功率、电压、功率因数、需用系数计算电流
            // 这里使用实际的电流计算公式
            let voltage = self.get_input_voltage(node_id).unwrap_or(220.0); // 默认220V
            let current = calculate_current(circuit_info.power, voltage, circuit_info.power_factor, circuit_info.coefficient);

            // 更新计算结果
            let cache_key = format!("circuit_current_{}", node_id.0);
            self.calculation_cache.insert(cache_key, current);

            // 更新节点数据
            // 注意：在实际应用中，需要通过可变引用更新节点数据
        }
    }

    // 获取输入电压
    fn get_input_voltage(&self, node_id: egui_node_graph::NodeId) -> Option<f64> {
        // 从输入参数或上游连接获取电压值
        // 这里需要实现实际的电压获取逻辑
        None
    }

    // 计算三相平衡
    fn calculate_phase_balance(&mut self) {
        // 遍历所有配电箱节点，计算三相平衡
        for node_id in self.graph.nodes.keys() {
            if let Some(node) = self.graph.nodes.get(node_id) {
                if let ElectricNodeType::DistributionBoxNode = node.user_data.node_type {
                    // 收集A/B/C相功率数据
                    let (phase_a, phase_b, phase_c) = self.collect_phase_powers(node_id);

                    // 计算不平衡度
                    let balance_degree = calculate_phase_balance_degree(phase_a, phase_b, phase_c);

                    // 存储结果
                    let cache_key = format!("balance_degree_{}", node_id.0);
                    self.calculation_cache.insert(cache_key, balance_degree);
                }
            }
        }
    }

    // 收集相功率
    fn collect_phase_powers(&self, distribution_box_id: egui_node_graph::NodeId) -> (f64, f64, f64) {
        // 实现收集配电箱连接的各相功率数据
        (0.0, 0.0, 0.0) // 默认值，需要实际实现
    }

    // 更新节点显示数据
    fn update_node_display_data(&mut self) {
        // 更新所有节点的显示数据，如计算结果、状态等
    }

    // 处理节点响应事件
    fn handle_node_responses(&mut self, responses: Vec<egui_node_graph::NodeResponse<ElectricNodeTemplate>>) {
        for response in responses {
            match response {
                egui_node_graph::NodeResponse::NodeAdded(node_id, template) => {
                    println!("添加节点: {:?} 节点ID: {:?}", template, node_id);
                    // 节点添加后的额外逻辑
                    self.on_node_added(node_id, &template);
                }
                egui_node_graph::NodeResponse::NodeRemoved(node_id) => {
                    println!("删除节点ID: {:?}", node_id);
                    // 节点删除后的清理逻辑
                    self.on_node_removed(node_id);
                }
                egui_node_graph::NodeResponse::ConnectionAdded(output_id, input_id) => {
                    println!("添加连接: {:?} -> {:?}", output_id, input_id);
                    // 电气系统连接类型兼容性检查
                    if let Some(output_node) = self.graph.nodes.get(&output_id.node_id) {
                        if let Some(input_node) = self.graph.nodes.get(&input_id.node_id) {
                            if let Some(output) = output_node.outputs.get(output_id.index) {
                                if let Some(input) = input_node.inputs.get(input_id.index) {
                                    // 电气系统专用的连接规则
                                    if !self.is_connection_valid(&output_node.user_data, &input_node.user_data, output.data_type, input.data_type) {
                                        // 不兼容的连接，移除连接并显示错误
                                        self.graph.remove_connection(output_id, input_id);
                                        self.error_message = Some(format!("连接规则不允许: {} -> {}",
                                            output_node.label, input_node.label));
                                    } else if output.data_type != input.data_type {
                                        // 数据类型不匹配
                                        self.graph.remove_connection(output_id, input_id);
                                        self.error_message = Some("连接数据类型不兼容".to_string());
                                    } else {
                                        // 连接成功，更新依赖关系
                                        self.update_dependencies();
                                        // 触发相关节点重新计算
                                        self.invalidate_affected_nodes(input_id.node_id);
                                    }
                                }
                            }
                        }
                    }
                }
                egui_node_graph::NodeResponse::ConnectionRemoved(input_id) => {
                    println!("删除连接: {:?}", input_id);
                    // 更新依赖关系
                    self.update_dependencies();
                    // 清除相关计算结果缓存
                    self.invalidate_affected_nodes(input_id.node_id);
                }
                egui_node_graph::NodeResponse::ParameterValueChanged(param_id, param_type) => {
                    println!("参数变更: {:?} 类型: {:?}", param_id, param_type);
                    // 找到参数所属的节点
                    if let Some(node_id) = self.find_node_by_param_id(param_id) {
                        // 使节点及下游节点失效
                        self.invalidate_affected_nodes(node_id);
                    }
                }
                egui_node_graph::NodeResponse::NodeDoubleClicked(node_id) => {
                    println!("双击节点: {:?}", node_id);
                    // 打开节点属性编辑对话框
                    self.open_node_properties_dialog(node_id);
                }
                egui_node_graph::NodeResponse::NodeSelected(node_ids) => {
                    println!("选中节点: {:?}", node_ids);
                    // 更新选中状态
                    self.selected_nodes = node_ids;
                }
                _ => {}
            }
        }
    }

    // 检查连接是否有效（电气系统规则）
    fn is_connection_valid(&self, output_node_data: &ElectricNodeData, input_node_data: &ElectricNodeData,
                          output_type: ElectricDataType, input_type: ElectricDataType) -> bool {
        // 定义电气系统的连接规则
        match (output_node_data.node_type, input_node_data.node_type) {
            // 电源节点只能连接到干线或配电箱
            (ElectricNodeType::PowerSourceNode, ElectricNodeType::MainLineNode) => true,
            (ElectricNodeType::PowerSourceNode, ElectricNodeType::DistributionBoxNode) => true,

            // 干线可以连接到配电箱
            (ElectricNodeType::MainLineNode, ElectricNodeType::DistributionBoxNode) => true,

            // 配电箱可以连接到配电回路
            (ElectricNodeType::DistributionBoxNode, ElectricNodeType::CircuitNode) => true,

            // 计算节点的连接规则
            (_, ElectricNodeType::CalculationNode) => true, // 任何节点都可以连接到计算节点
            (ElectricNodeType::CalculationNode, _) => true, // 计算节点可以连接到任何节点

            // 其他连接类型需要根据具体的数据类型判断
            _ => {
                // 电压/电流/功率信号可以在不同节点间传递
                matches!((output_type, input_type),
                    (ElectricDataType::Voltage, ElectricDataType::Voltage) |
                    (ElectricDataType::Current, ElectricDataType::Current) |
                    (ElectricDataType::Power, ElectricDataType::Power) |
                    (ElectricDataType::PhaseInfo, ElectricDataType::PhaseInfo))
            }
        }
    }

    // 更新节点依赖关系
    fn update_dependencies(&mut self) {
        // 实现节点依赖关系图的更新
        // 这对于确定计算顺序很重要
    }

    // 使受影响的节点计算结果失效
    fn invalidate_affected_nodes(&mut self, start_node_id: egui_node_graph::NodeId) {
        // 清除当前节点及所有下游节点的计算结果缓存
        let affected_nodes = self.find_downstream_nodes(start_node_id);

        for node_id in affected_nodes {
            // 清除与该节点相关的所有缓存项
            let cache_keys: Vec<String> = self.calculation_cache.keys()
                .filter(|key| key.contains(&node_id.0.to_string()))
                .cloned()
                .collect();

            for key in cache_keys {
                self.calculation_cache.remove(&key);
            }
        }
    }

    // 查找下游节点
    fn find_downstream_nodes(&self, start_node_id: egui_node_graph::NodeId) -> Vec<egui_node_graph::NodeId> {
        let mut downstream = Vec::new();
        let mut visited = std::collections::HashSet::new();

        self.find_downstream_recursive(start_node_id, &mut downstream, &mut visited);
        downstream
    }

    // 递归查找下游节点
    fn find_downstream_recursive(&self, node_id: egui_node_graph::NodeId, downstream: &mut Vec<egui_node_graph::NodeId>,
                               visited: &mut std::collections::HashSet<egui_node_graph::NodeId>) {
        if visited.contains(&node_id) {
            return;
        }

        visited.insert(node_id);

        // 找到所有使用此节点输出的下游节点
        for connection in &self.graph.connections {
            if connection.output.node_id == node_id {
                let target_node_id = connection.input.node_id;
                downstream.push(target_node_id);
                self.find_downstream_recursive(target_node_id, downstream, visited);
            }
        }
    }

    // 查找参数所属的节点
    fn find_node_by_param_id(&self, param_id: egui_node_graph::ParamId) -> Option<egui_node_graph::NodeId> {
        // 遍历所有节点查找参数ID
        for (node_id, node) in &self.graph.nodes {
            // 检查输入参数
            for (input_id, _) in &node.inputs {
                if input_id == &param_id {
                    return Some(*node_id);
                }
            }
            // 检查输出参数
            for (output_id, _) in &node.outputs {
                if output_id == &param_id {
                    return Some(*node_id);
                }
            }
        }
        None
    }

    // 打开节点属性编辑对话框
    fn open_node_properties_dialog(&mut self, node_id: egui_node_graph::NodeId) {
        // 这里可以实现节点属性对话框
        // 例如编辑节点参数、调整计算选项等
    }

    // 节点添加后的处理
    fn on_node_added(&mut self, node_id: egui_node_graph::NodeId, template: &ElectricNodeTemplate) {
        // 根据节点类型初始化默认值或连接
        match template {
            ElectricNodeTemplate::CircuitNode => self.initialize_circuit_node(node_id),
            ElectricNodeTemplate::DistributionBoxNode => self.initialize_distribution_box_node(node_id),
            ElectricNodeTemplate::PowerSourceNode => self.initialize_power_source_node(node_id),
            _ => {}
        }
    }

    // 初始化配电回路节点
    fn initialize_circuit_node(&mut self, node_id: egui_node_graph::NodeId) {
        // 设置默认参数值
    }

    // 初始化配电箱节点
    fn initialize_distribution_box_node(&mut self, node_id: egui_node_graph::NodeId) {
        // 设置默认参数值和三相平衡信息
    }

    // 初始化电源节点
    fn initialize_power_source_node(&mut self, node_id: egui_node_graph::NodeId) {
        // 设置默认电压、频率等值
    }

    // 节点删除后的清理
    fn on_node_removed(&mut self, node_id: egui_node_graph::NodeId) {
        // 清理相关计算缓存
        self.invalidate_affected_nodes(node_id);

        // 清理选中状态
        if let Some(pos) = self.selected_nodes.iter().position(|&id| id == node_id) {
            self.selected_nodes.remove(pos);
        }
    }
}
```
