# 数据结构定义方案

## 1. 概述

本文档定义了配电系统设计工具中使用的核心数据结构，基于实际代码实现，包括回路数据、开关元器件数据、电流计算相关类型等。这些数据结构是整个系统的基础，确保了数据的一致性和完整性。

> 注：本文档基于 `src/editor/business/text_circuit.rs`、`src/editor/business/text_switching_components.rs` 和 `src/core_lib/algorithm/current_calculation.rs` 的实际代码实现进行整理和优化。

## 2. 核心数据类型

### 2.1 回路编号类型

根据实际代码实现，回路编号类型支持三种形式：

```rust
/// 回路编号类型枚举
#[derive(Debug, Clone, PartialEq)]
pub enum CircuitNumber {
    // 类型1：字母+数字（如"N1, N2..."）
    LetterNumber {
        letter: char,        // 字母（如'N'、'P'）
        current_number: u32, // 当前数字（从1开始）
    },
    //类型2： 双字母+数字（如"WL1, WX2..."）
    TwoLettersNumber {
        prefix: &'static str, // 固定双字母前缀（如"WL"、"WX"）
        current_number: u32,
    },
    // 类型3：配电箱编号+'-'+数字（如"1AL-1, 1AL-2..."）
    DistributionBox {
        box_id: String,      // 配电箱编号（如"1AL"、"2AP"）
        current_number: u32, // 当前数字（从1开始）
    },
}

impl CircuitNumber {
    // 创建单字母类型
    pub fn new_single_letter(letter: char) -> Self {
        Self::LetterNumber {
            letter,
            current_number: 1,
        }
    }
    // 创建双字母类型
    pub fn new_two_letters(prefix: &'static str) -> Self {
        // 简单校验：确保前缀是2个字符（可选）
        debug_assert_eq!(prefix.len(), 2, "双字母前缀必须是2个字符");
        Self::TwoLettersNumber {
            prefix,
            current_number: 1,
        }
    }

    // 创建配电箱初始编号（关联函数，接收外部box_id）
    pub fn new_box_initial(box_id: &str) -> Self {
        Self::DistributionBox {
            box_id: box_id.to_string(),
            current_number: 1, // 初始编号从1开始
        }
    }
    // 创建配电箱类型
    pub fn new_box(&self) -> Self {
        match self {
            Self::DistributionBox {
                box_id,
                current_number,
            } => CircuitNumber::DistributionBox {
                box_id: box_id.clone(),
                current_number: current_number + 1,
            },
            _ => todo!("仅配电箱类型可调用new_box方法"),
        }
    }

    // 生成当前编号字符串
    pub fn to_string(&self) -> String {
        match self {
            Self::LetterNumber {
                letter,
                current_number,
            } => {
                format!("{}{}", letter, current_number)
            }
            Self::TwoLettersNumber {
                prefix,
                current_number,
            } => {
                format!("{}{}", prefix, current_number)
            }
            CircuitNumber::DistributionBox {
                box_id,
                current_number,
            } => {
                format!("{}-{}", box_id, current_number)
            }
        }
    }

    // 生成下一个编号
    pub fn next(&self) -> Self {
        match self {
            Self::LetterNumber {
                letter,
                current_number,
            } => Self::LetterNumber {
                letter: *letter,
                current_number: current_number + 1,
            },
            Self::TwoLettersNumber {
                prefix,
                current_number,
            } => Self::TwoLettersNumber {
                prefix,
                current_number: current_number + 1,
            },
            Self::DistributionBox {
                box_id,
                current_number,
            } => Self::DistributionBox {
                box_id: box_id.clone(),
                current_number: current_number + 1,
            },
        }
    }
}
```

### 2.2 回路用途和功率类型

```rust
/// 回路用途,支持手动输入或从外部参数获取
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CircuitPurpose {
    // 手动输入的用途
    Manual(String),
    // 从外部参数获取的用途（未来关联到具体参数源）
    External {
        source_id: String, // 外部参数的唯一标识（如设备ID、配置项ID）
        value: String,     // 用途值（从外部获取后存储）
    },
}

impl CircuitPurpose {
    /// 创建手动输入的回路用途
    pub fn from_manual(input: &str) -> Self {
        Self::Manual(input.to_string())
    }
    /// 创建从外部参数获取的回路用途
    pub fn from_external(source_id: &str, value: &str) -> Self {
        Self::External {
            source_id: source_id.to_string(),
            value: value.to_string(),
        }
    }
    /// 获取用途的字符串表示（统一接口）
    pub fn to_string(&self) -> &str {
        match self {
            Self::Manual(s) => s,
            Self::External { value, .. } => value,
        }
    }
}

/// 回路功率：支持手动输入或从外部配电箱参数获取
#[derive(Debug, Clone, PartialEq)]
pub enum CircuitPower {
    // 手动输入的功率（仅需数值，自动添加kW单位）
    Manual {
        value: f32,  // 功率数值（如10.5表示10.5kW）
    },
    // 从外部配电箱参数获取的功率
    External {
        source_id: String,  // 外部配电箱标识
        value: f32,         // 功率数值（自动以kW为单位）
    },
}

impl CircuitPower {
    /// 创建手动输入的回路功率
    pub fn from_manual(input: &str) -> Result<Self, &'static str> {
        let value = input.parse().map_err(|_| {
            "无效的功率数值，请输入数字（如10、7.5）"
        })?;
        Ok(Self::Manual { value })
    }

    /// 创建从外部配电箱获取的回路功率
    pub fn from_external(source_id: &str, value: f32) -> Result<Self, &'static str> {
        Ok(Self::External {
            source_id: source_id.to_string(),
            value,
        })
    }

    /// 获取带单位的功率字符串
    pub fn to_string(&self) -> String {
        let value = match self {
            Self::Manual { value } => *value,
            Self::External { value, .. } => *value,
        };

        if value.fract() == 0.0 {
            format!("{}kW", value as u32)
        } else {
            format!("{}kW", value)
        }
    }
}
```

### 1.3 电压等级和相序

```rust
/// 电压等级
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum VoltageLevel {
    V400_750,
    V600_1000,
}
impl VoltageLevel {
    pub fn to_str(&self) -> &'static str {
        match self {
            VoltageLevel::V400_750 => "400V/750V",
            VoltageLevel::V600_1000 => "0.6V/1kV",
        }
    }
}

/// 相序
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PhaseSequence {
    L1,
    L2,
    L3,
    L1L2L3,
}
impl PhaseSequence {
    pub fn to_str(&self) -> &'static str {
        match self {
            PhaseSequence::L1 => "L1",
            PhaseSequence::L2 => "L2",
            PhaseSequence::L3 => "L3",
            PhaseSequence::L1L2L3 => "L1L2L3",
        }
    }
}
```

### 1.4 线缆规格与并联电缆

```rust
/// 相线截面积规格
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PhaseLine {
    M1_5,
    M2_5,
    M4,
    M6,
    M10,
    M16,
    M25,
    M35,
    M50,
    M70,
    M95,
    M120,
    M150,
    M185,
    M240,
}

impl PhaseLine {
    pub fn to_str(&self) -> &'static str {
        match self {
            Self::M1_5 => "1.5",
            Self::M2_5 => "2.5",
            Self::M4 => "4",
            Self::M6 => "6",
            Self::M10 => "10",
            Self::M16 => "16",
            Self::M25 => "25",
            Self::M35 => "35",
            Self::M50 => "50",
            Self::M70 => "70",
            Self::M95 => "95",
            Self::M120 => "120",
            Self::M150 => "150",
            Self::M185 => "185",
            Self::M240 => "240",
        }
    }
    
    /// 获取对应的PE线规格
    pub fn corresponding_pe(&self) -> PE {
        match self {
            Self::M1_5 => PE::M1_5,
            Self::M2_5 => PE::M2_5,
            Self::M4 => PE::M4,
            Self::M6 => PE::M6,
            Self::M10 => PE::M10,
            Self::M16 => PE::M16,
            Self::M25 => PE::M16,
            Self::M35 => PE::M16,
            Self::M50 => PE::M25,
            Self::M70 => PE::M35,
            Self::M95 => PE::M50,
            Self::M120 => PE::M70,
            Self::M150 => PE::M70,
            Self::M185 => PE::M95,
            Self::M240 => PE::M120,
        }
    }
}

/// PE线截面积规格
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PE {
    M1_5,
    M2_5,
    M4,
    M6,
    M10,
    M16,
    M25,
    M35,
    M50,
    M70,
    M95,
    M120,
}

impl PE {
    pub fn to_str(&self) -> &'static str {
        match self {
            Self::M1_5 => "1.5",
            Self::M2_5 => "2.5",
            Self::M4 => "4",
            Self::M6 => "6",
            Self::M10 => "10",
            Self::M16 => "16",
            Self::M25 => "25",
            Self::M35 => "35",
            Self::M50 => "50",
            Self::M70 => "70",
            Self::M95 => "95",
            Self::M120 => "120",
        }
    }
}

/// 双根并联电缆
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TwinParallelCables {
    TC1_5,
    TC2_5,
    TC4,
    TC6,
    TC10,
    TC16,
    TC25,
    TC35,
    TC50,
    TC70,
    TC95,
    TC120,
    TC150,
    TC185,
    TC240,
}

impl TwinParallelCables {
    pub fn to_str(&self) -> &'static str {
        match self {
            Self::TC1_5 => "1.5",
            Self::TC2_5 => "2.5",
            Self::TC4 => "4",
            Self::TC6 => "6",
            Self::TC10 => "10",
            Self::TC16 => "16",
            Self::TC25 => "25",
            Self::TC35 => "35",
            Self::TC50 => "50",
            Self::TC70 => "70",
            Self::TC95 => "95",
            Self::TC120 => "120",
            Self::TC150 => "150",
            Self::TC185 => "185",
            Self::TC240 => "240",
        }
    }
}

/// 电缆芯数与配置
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum CoresNum {
    C2_1(PhaseLine, PE),              // 2芯+PE
    C4_1(PhaseLine, Option<TwinParallelCables>, PE), // 4芯+PE
    C4(PhaseLine, Option<TwinParallelCables>),       // 4芯
}

impl CoresNum {
    /// 创建2芯+PE配置
    pub fn new_c2_1(phase: PhaseLine, pe: PE) -> Result<Self, &'static str> {
        if pe != phase.corresponding_pe() {
            return Err("PE值与Phase不匹配，请使用对应的PE值");
        }
        Ok(Self::C2_1(phase, pe))
    }

    /// 创建4芯+PE配置
    pub fn new_c4_1(phase: PhaseLine, pe: PE) -> Result<Self, &'static str> {
        if pe != phase.corresponding_pe() {
            return Err("PE值与相线不匹配");
        }
        Ok(Self::C4_1(phase, None, pe))
    }
    
    /// 创建4芯配置
    pub fn new_c4(phase: PhaseLine) -> Self {
        Self::C4(phase, None)
    }
    
    /// 创建双根并联的4芯+PE配置
    pub fn new_twin_c4_1(phase: PhaseLine, twin: TwinParallelCables, pe: PE) -> Result<Self, &'static str> {
        if pe != phase.corresponding_pe() {
            return Err("PE值与相线不匹配");
        }
        Ok(Self::C4_1(phase, Some(twin), pe))
    }
    
    /// 创建双根并联的4芯配置
    pub fn new_twin_c4(phase: PhaseLine, twin: TwinParallelCables) -> Self {
        Self::C4(phase, Some(twin))
    }
    
    /// 生成规格字符串表示
    pub fn to_spec_str(&self) -> String {
        match self {
            CoresNum::C2_1(phase, pe) => {
                format!("2x{}+PE{}", phase.to_str(), pe.to_str())
            }
            CoresNum::C4_1(phase, twin, pe) => match twin {
                None => format!("4x{}+PE{}", phase.to_str(), pe.to_str()),
                Some(twin_cable) => {
                    let inner_str = format!("4x{}+PE{}", twin_cable.to_str(), pe.to_str());
                    format!("2x({})")
                }
            },
            CoresNum::C4(phase, twin) => match twin {
                None => format!("4x{}", phase.to_str()),
                Some(twin_cable) => {
                    format!("2x(4x{})")
                }
            },
        }
    }
}
```

## 三、配电箱数据结构

### 3.1 DistributionBoxData 结构体

```rust
// 配电箱数据结构
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct DistributionBoxData {
    pub id: String,                      // 唯一标识符
    pub name: String,                    // 配电箱名称
    pub number: CircuitNumber,           // 配电箱编号
    pub incoming_circuit: Option<String>, // 进线回路ID
    pub outgoing_circuits: Vec<String>,  // 出线回路ID列表
    pub total_power: Power,              // 总功率(kW)
    pub total_current: Current,          // 总电流(A)
    pub voltage_level: VoltageLevel,     // 电压等级
    pub phase_count: u8,                 // 相数(1或3)
    pub main_protection: BreakerSpec,    // 主保护设备
    pub monitoring_module: Option<MonitoringModule>, // 监测模块
    pub phase_balance: PhaseBalance,     // 三相平衡信息
    pub location: String,                // 安装位置
    pub dimensions: Dimensions,          // 箱体尺寸
    pub manufacturer: Option<String>,    // 制造商
}

// 监测模块结构体
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct MonitoringModule {
    pub has_voltage_monitor: bool,     // 电压监测
    pub has_current_monitor: bool,     // 电流监测
    pub has_power_monitor: bool,       // 功率监测
    pub has_energy_meter: bool,        // 电能计量
    pub has_temperature_monitor: bool, // 温度监测
    pub communication_protocol: String, // 通信协议
}

// 三相平衡信息
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct PhaseBalance {
    pub phase_a_power: Power,          // A相功率
    pub phase_b_power: Power,          // B相功率
    pub phase_c_power: Power,          // C相功率
    pub phase_a_current: Current,      // A相电流
    pub phase_b_current: Current,      // B相电流
    pub phase_c_current: Current,      // C相电流
    pub unbalance_degree: f64,         // 不平衡度
}

// 箱体尺寸
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
struct Dimensions {
    pub width: f64,                    // 宽度(mm)
    pub height: f64,                   // 高度(mm)
    pub depth: f64,                    // 深度(mm)
}

// DistributionBoxData 实现的功能方法
impl DistributionBoxData {
    // 1. 计算总功率和电流
    fn calculate_total_power(&mut self, circuits: &[CircuitData]) {
        self.total_power = 0.0;
        
        // 计算总功率
        for circuit_id in &self.outgoing_circuits {
            if let Some(circuit) = circuits.iter().find(|c| c.id == *circuit_id) {
                self.total_power += circuit.power;
            }
        }
        
        // 计算总电流
        let voltage = match self.voltage_level {
            VoltageLevel::LowVoltage => 0.38,  // 0.38kV
            VoltageLevel::MediumVoltage => 10.0, // 10kV
            VoltageLevel::HighVoltage => 35.0,  // 35kV
        };
        
        let power_factor = 0.85; // 平均功率因数
        
        if self.phase_count == 3 {
            // 三相计算
            self.total_current = self.total_power / (1.732 * voltage * power_factor);
        } else {
            // 单相计算
            self.total_current = self.total_power / (voltage * power_factor);
        }
    }
    
    // 2. 计算三相平衡
    fn calculate_phase_balance(&mut self, circuits: &[CircuitData]) {
        let mut phase_a_power = 0.0;
        let mut phase_b_power = 0.0;
        let mut phase_c_power = 0.0;
        let mut phase_a_current = 0.0;
        let mut phase_b_current = 0.0;
        let mut phase_c_current = 0.0;
        
        // 统计各相功率和电流
        for circuit_id in &self.outgoing_circuits {
            if let Some(circuit) = circuits.iter().find(|c| c.id == *circuit_id) {
                match circuit.phase {
                    Phase::A => {
                        phase_a_power += circuit.power;
                        phase_a_current += circuit.current;
                    },
                    Phase::B => {
                        phase_b_power += circuit.power;
                        phase_b_current += circuit.current;
                    },
                    Phase::C => {
                        phase_c_power += circuit.power;
                        phase_c_current += circuit.current;
                    },
                    _ => {}, // 忽略零线和地线
                }
            }
        }
        
        // 计算不平衡度
        let max_power = phase_a_power.max(phase_b_power).max(phase_c_power);
        let min_power = phase_a_power.min(phase_b_power).min(phase_c_power);
        let avg_power = (phase_a_power + phase_b_power + phase_c_power) / 3.0;
        let unbalance_degree = if avg_power > 0.0 {
            (max_power - min_power) / avg_power * 100.0
        } else {
            0.0
        };
        
        self.phase_balance = PhaseBalance {
            phase_a_power,
            phase_b_power,
            phase_c_power,
            phase_a_current,
            phase_b_current,
            phase_c_current,
            unbalance_degree,
        };
    }
    
    // 3. 智能调整三相平衡
    fn optimize_phase_balance(&mut self, circuits: &mut [CircuitData]) {
        if self.phase_count != 3 || self.outgoing_circuits.len() < 3 {
            return; // 非三相系统或回路太少，不需要平衡
        }
        
        let mut phase_a_circuits = Vec::new();
        let mut phase_b_circuits = Vec::new();
        let mut phase_c_circuits = Vec::new();
        
        // 收集各相回路
        for circuit_id in &self.outgoing_circuits {
            if let Some(index) = circuits.iter().position(|c| c.id == *circuit_id) {
                let phase = circuits[index].phase;
                match phase {
                    Phase::A => phase_a_circuits.push(index),
                    Phase::B => phase_b_circuits.push(index),
                    Phase::C => phase_c_circuits.push(index),
                    _ => {},
                }
            }
        }
        
        // 计算各相总功率
        let phase_a_total: Power = phase_a_circuits.iter().map(|&i| circuits[i].power).sum();
        let phase_b_total: Power = phase_b_circuits.iter().map(|&i| circuits[i].power).sum();
        let phase_c_total: Power = phase_c_circuits.iter().map(|&i| circuits[i].power).sum();
        
        // 找出功率最大和最小的相
        let max_phase = if phase_a_total >= phase_b_total && phase_a_total >= phase_c_total {
            (&mut phase_a_circuits, Phase::A, phase_a_total)
        } else if phase_b_total >= phase_a_total && phase_b_total >= phase_c_total {
            (&mut phase_b_circuits, Phase::B, phase_b_total)
        } else {
            (&mut phase_c_circuits, Phase::C, phase_c_total)
        };
        
        let min_phase = if phase_a_total <= phase_b_total && phase_a_total <= phase_c_total {
            (&mut phase_a_circuits, Phase::A, phase_a_total)
        } else if phase_b_total <= phase_a_total && phase_b_total <= phase_c_total {
            (&mut phase_b_circuits, Phase::B, phase_b_total)
        } else {
            (&mut phase_c_circuits, Phase::C, phase_c_total)
        };
        
        // 如果不平衡度大于20%，尝试调整
        let unbalance = (max_phase.2 - min_phase.2) / (max_phase.2 + phase_b_total + phase_c_total) * 300.0;
        if unbalance > 20.0 && !max_phase.0.is_empty() {
            // 从功率最大的相选择一个回路移到功率最小的相
            let max_circuit_index = max_phase.0.iter().max_by_key(|&&i| circuits[i].power).copied();
            if let Some(index) = max_circuit_index {
                circuits[index].phase = min_phase.1;
                // 更新回路列表
                max_phase.0.retain(|&i| i != index);
                min_phase.0.push(index);
            }
        }
    }
    
    // 4. 自动生成回路编号
    fn generate_circuit_numbers(&self, circuits: &mut [CircuitData]) {
        let mut phase_a_count = 0;
        let mut phase_b_count = 0;
        let mut phase_c_count = 0;
        
        // 统计各相已有回路数量
        for circuit in circuits.iter() {
            if self.outgoing_circuits.contains(&circuit.id) {
                match circuit.phase {
                    Phase::A => phase_a_count += 1,
                    Phase::B => phase_b_count += 1,
                    Phase::C => phase_c_count += 1,
                    _ => {},
                }
            }
        }
        
        // 为无编号的回路生成编号
        for circuit in circuits.iter_mut() {
            if self.outgoing_circuits.contains(&circuit.id) && circuit.number.number == 0 {
                let (count, phase_str) = match circuit.phase {
                    Phase::A => {
                        phase_a_count += 1;
                        (phase_a_count, "A")
                    },
                    Phase::B => {
                        phase_b_count += 1;
                        (phase_b_count, "B")
                    },
                    Phase::C => {
                        phase_c_count += 1;
                        (phase_c_count, "C")
                    },
                    _ => (0, "N"),
                };
                
                if count > 0 {
                    circuit.number = CircuitNumber {
                        prefix: "WL".to_string(),
                        number: count,
                        subfix: Some(phase_str.to_string()),
                    };
                }
            }
        }
    }
}
```

## 四、干线系统图数据结构

### 4.1 TrunkSystemData 结构体

```rust
// 干线系统图数据结构
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct TrunkSystemData {
    pub id: String,                      // 唯一标识符
    pub name: String,                    // 系统名称
    pub description: String,             // 系统描述
    pub distribution_boxes: Vec<String>, // 配电箱ID列表
    pub transformers: Vec<String>,       // 变压器ID列表
    pub connections: Vec<Connection>,    // 连接关系
    pub voltage_level: VoltageLevel,     // 系统电压等级
    pub system_type: SystemType,         // 系统类型
    pub load_classification: Vec<LoadCategory>, // 负载分类
}

// 连接关系结构体
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct Connection {
    pub id: String,                      // 连接ID
    pub source_id: String,               // 源设备ID
    pub target_id: String,               // 目标设备ID
    pub connection_type: ConnectionType, // 连接类型
    pub cable: CableSpec,                // 线缆规格
    pub length: f64,                     // 连接长度(m)
    pub is_main: bool,                   // 是否为主干线
}

// 系统类型枚举
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
enum SystemType {
    Radial,          // 放射式
   树干式,          // Trunk
    Ring,            // 环式
    Hybrid,          // 混合式
}

// 连接类型枚举
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
enum ConnectionType {
    Primary,         // 一次侧
    Secondary,       // 二次侧
    Busbar,          // 母线连接
    Feeder,          // 馈线连接
}

// 负载分类结构体
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct LoadCategory {
    pub name: String,                    // 类别名称
    pub description: String,             // 类别描述
    pub total_power: Power,              // 总功率
    pub load_level: LoadLevel,           // 负载等级
}

// 负载等级枚举
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
enum LoadLevel {
    First,           // 一级负荷
    Second,          // 二级负荷
    Third,           // 三级负荷
}

// TrunkSystemData 实现的功能方法
impl TrunkSystemData {
    // 1. 自动映射配电箱层级关系
    fn map_box_hierarchy(&mut self, boxes: &[DistributionBoxData]) {
        // 构建层级映射表
        let mut hierarchy_map = HashMap::new();
        let mut connections_to_add = Vec::new();
        
        // 遍历所有配电箱，分析上下级关系
        for box_data in boxes {
            if let Some(incoming_id) = &box_data.incoming_circuit {
                // 查找进线回路所属的配电箱
                for source_box in boxes {
                    if source_box.outgoing_circuits.contains(incoming_id) {
                        hierarchy_map.entry(source_box.id.clone())
                            .or_insert_with(Vec::new)
                            .push(box_data.id.clone());
                        
                        // 创建连接关系
                        connections_to_add.push(Connection {
                            id: format!("conn_{}_{}", source_box.id, box_data.id),
                            source_id: source_box.id.clone(),
                            target_id: box_data.id.clone(),
                            connection_type: ConnectionType::Feeder,
                            cable: CableSpec {
                                r#type: "YJV".to_string(),
                                cross_section: 16.0, // 默认截面积
                                core_count: 4,
                                insulation_level: self.voltage_level,
                            },
                            length: 10.0, // 默认长度
                            is_main: false,
                        });
                        break;
                    }
                }
            }
        }
        
        // 添加新的连接
        for conn in connections_to_add {
            if !self.connections.iter().any(|c| c.id == conn.id) {
                self.connections.push(conn);
            }
        }
    }
    
    // 2. 智能识别并生成连线
    fn generate_connections(&mut self, boxes: &[DistributionBoxData]) {
        // 确保所有配电箱都在系统中
        for box_data in boxes {
            if !self.distribution_boxes.contains(&box_data.id) {
                self.distribution_boxes.push(box_data.id.clone());
            }
        }
        
        // 自动映射层级关系
        self.map_box_hierarchy(boxes);
        
        // 确保每个配电箱除了根节点外都有进线连接
        for box_id in &self.distribution_boxes {
            if !self.connections.iter().any(|c| c.target_id == *box_id) {
                // 这可能是一个孤立的配电箱或根节点
                // 检查是否有其他配电箱的出线连接到它
                for other_box in boxes {
                    if other_box.outgoing_circuits.iter().any(|circuit_id| {
                        // 查找回路连接的终点是否是当前配电箱
                        boxes.iter().any(|b| {
                            b.id == *box_id && b.incoming_circuit == Some(circuit_id.clone())
                        })
                    }) {
                        // 创建缺失的连接
                        let new_conn = Connection {
                            id: format!("conn_{}_{}", other_box.id, box_id),
                            source_id: other_box.id.clone(),
                            target_id: box_id.clone(),
                            connection_type: ConnectionType::Feeder,
                            cable: CableSpec {
                                r#type: "YJV".to_string(),
                                cross_section: 16.0,
                                core_count: 4,
                                insulation_level: self.voltage_level,
                            },
                            length: 10.0,
                            is_main: false,
                        };
                        
                        if !self.connections.iter().any(|c| c.id == new_conn.id) {
                            self.connections.push(new_conn);
                        }
                    }
                }
            }
        }
    }
    
    // 3. 分析系统拓扑结构
    fn analyze_topology(&self) -> SystemTopology {
        let mut topology = SystemTopology {
            root_boxes: Vec::new(),
            leaf_boxes: Vec::new(),
            branches: Vec::new(),
            depth: 0,
        };
        
        // 查找根节点（没有入连接的配电箱）
        for box_id in &self.distribution_boxes {
            if !self.connections.iter().any(|c| c.target_id == *box_id) {
                topology.root_boxes.push(box_id.clone());
            }
        }
        
        // 查找叶节点（没有出连接的配电箱）
        for box_id in &self.distribution_boxes {
            if !self.connections.iter().any(|c| c.source_id == *box_id) {
                topology.leaf_boxes.push(box_id.clone());
            }
        }
        
        // 计算系统深度（通过递归计算每个根节点的最大深度）
        for root_id in &topology.root_boxes {
            let depth = self.calculate_depth(root_id, &mut HashMap::new());
            topology.depth = topology.depth.max(depth);
        }
        
        // 构建分支信息
        for conn in &self.connections {
            topology.branches.push(Branch {
                source: conn.source_id.clone(),
                target: conn.target_id.clone(),
                connection_id: conn.id.clone(),
            });
        }
        
        topology
    }
    
    // 辅助方法：计算从指定节点开始的深度
    fn calculate_depth(&self, box_id: &str, visited: &mut HashMap<String, u32>) -> u32 {
        // 如果已经访问过，返回缓存的深度
        if let Some(&depth) = visited.get(box_id) {
            return depth;
        }
        
        // 查找所有从当前节点出发的连接
        let mut max_child_depth = 0;
        for conn in &self.connections {
            if conn.source_id == *box_id {
                let child_depth = self.calculate_depth(&conn.target_id, visited);
                max_child_depth = max_child_depth.max(child_depth);
            }
        }
        
        // 当前深度 = 最大子深度 + 1
        let current_depth = max_child_depth + 1;
        visited.insert(box_id.to_string(), current_depth);
        current_depth
    }
}

// 系统拓扑结构体
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct SystemTopology {
    pub root_boxes: Vec<String>,         // 根配电箱
    pub leaf_boxes: Vec<String>,         // 叶配电箱
    pub branches: Vec<Branch>,           // 分支信息
    pub depth: u32,                      // 系统深度
}

// 分支信息结构体
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct Branch {
    pub source: String,                  // 源配电箱ID
    pub target: String,                  // 目标配电箱ID
    pub connection_id: String,           // 连接ID
}

// 连接关系结构体
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct Connection {
    pub id: String,                      // 连接ID
    pub source_id: String,               // 源设备ID
    pub target_id: String,               // 目标设备ID
    pub connection_type: ConnectionType, // 连接类型
    pub cable: CableSpec,                // 线缆规格
    pub length: f64,                     // 连接长度(m)
    pub is_main: bool,                   // 是否为主干线
    pub cable_info: CableInfo,           // 连接电缆信息
}

impl TrunkSystemData {
    /// 创建新的干线系统数据
    pub fn new(system_id: String, system_name: String) -> Self {
        Self {
            system_id,
            system_name,
            voltage_level: VoltageLevel::V400_750,
            system_type: SystemType::Radial,
            distribution_boxes: HashMap::new(),
            connections: Vec::new(),
            hierarchy_map: HashMap::new(),
            incoming_circuit: None,
        }
    }

    /// 添加配电箱
    pub fn add_distribution_box(&mut self, box_data: DistributionBoxData) {
        self.distribution_boxes.insert(box_data.id.clone(), box_data);
    }

    /// 移除配电箱
    pub fn remove_distribution_box(&mut self, box_id: &str) -> Option<DistributionBoxData> {
        let removed = self.distribution_boxes.remove(box_id);
        
        if removed.is_some() {
            // 移除相关连接
            self.connections.retain(|conn| conn.from_box_id != box_id && conn.to_box_id != box_id);
            // 移除层级映射
            self.hierarchy_map.remove(box_id);
            for children in self.hierarchy_map.values_mut() {
                children.retain(|child_id| child_id != box_id);
            }
        }
        
        removed
    }

    /// 添加连接
    pub fn add_connection(&mut self, connection: Connection) {
        // 验证配电箱是否存在
        if !self.distribution_boxes.contains_key(&connection.from_box_id) || 
           !self.distribution_boxes.contains_key(&connection.to_box_id) {
            return;
        }
        
        // 添加连接
        self.connections.push(connection.clone());
        
        // 更新层级映射
        self.hierarchy_map
            .entry(connection.from_box_id)
            .or_insert_with(Vec::new)
            .push(connection.to_box_id);
    }

    /// 生成系统层级结构
    pub fn generate_hierarchy(&mut self) {
        // 清空现有的层级映射
        self.hierarchy_map.clear();
        
        // 构建层级映射
        for connection in &self.connections {
            self.hierarchy_map
                .entry(connection.from_box_id.clone())
                .or_insert_with(Vec::new)
                .push(connection.to_box_id.clone());
        }
    }

    /// 获取指定配电箱的所有子配电箱
    pub fn get_child_boxes(&self, box_id: &str) -> Vec<&DistributionBoxData> {
        let mut result = Vec::new();
        let mut visited = HashSet::new();
        let mut to_visit = vec![box_id.to_string()];
        
        while let Some(current_id) = to_visit.pop() {
            if visited.contains(&current_id) {
                continue;
            }
            
            visited.insert(current_id.clone());
            
            if let Some(children) = self.hierarchy_map.get(&current_id) {
                for child_id in children {
                    if let Some(box_data) = self.distribution_boxes.get(child_id) {
                        result.push(box_data);
                        to_visit.push(child_id.clone());
                    }
                }
            }
        }
        
        result
    }

    /// 获取指定配电箱的所有父配电箱
    pub fn get_parent_boxes(&self, box_id: &str) -> Vec<&DistributionBoxData> {
        let mut result = Vec::new();
        let mut visited = HashSet::new();
        let mut to_visit = vec![box_id.to_string()];
        
        while let Some(current_id) = to_visit.pop() {
            if visited.contains(&current_id) {
                continue;
            }
            
            visited.insert(current_id.clone());
            
            // 查找所有连接到当前配电箱的配电箱
            for connection in &self.connections {
                if connection.to_box_id == current_id && !visited.contains(&connection.from_box_id) {
                    if let Some(box_data) = self.distribution_boxes.get(&connection.from_box_id) {
                        result.push(box_data);
                        to_visit.push(connection.from_box_id.clone());
                    }
                }
            }
        }
        
        result
    }

    /// 重新计算所有配电箱的负荷
    pub fn recalculate_all_loads(&mut self) {
        for box_data in self.distribution_boxes.values_mut() {
            box_data.recalculate_total_load();
            box_data.recalculate_three_phase_balance();
        }
    }

    /// 进行拓扑分析
    pub fn analyze_topology(&self) -> TopologyAnalysisResult {
        let mut result = TopologyAnalysisResult {
            total_boxes: self.distribution_boxes.len(),
            total_connections: self.connections.len(),
            root_boxes: Vec::new(),
            leaf_boxes: Vec::new(),
            has_cycles: false,
            isolated_boxes: Vec::new(),
        };
        
        // 找出根节点（没有入边的节点）
        let mut has_incoming = HashSet::new();
        for connection in &self.connections {
            has_incoming.insert(&connection.to_box_id);
        }
        
        for box_id in self.distribution_boxes.keys() {
            if !has_incoming.contains(box_id) {
                result.root_boxes.push(box_id.clone());
            }
        }
        
        // 找出叶子节点（没有出边的节点）
        let mut has_outgoing = HashSet::new();
        for connection in &self.connections {
            has_outgoing.insert(&connection.from_box_id);
        }
        
        for box_id in self.distribution_boxes.keys() {
            if !has_outgoing.contains(box_id) {
                result.leaf_boxes.push(box_id.clone());
            }
        }
        
        // 检查是否有环
        result.has_cycles = self.check_for_cycles();
        
        // 找出孤立的配电箱
        let connected_boxes: HashSet<_> = self.connections.iter()
            .flat_map(|c| vec![&c.from_box_id, &c.to_box_id])
            .collect();
        
        for box_id in self.distribution_boxes.keys() {
            if !connected_boxes.contains(box_id) {
                result.isolated_boxes.push(box_id.clone());
            }
        }
        
        result
    }

    /// 检查是否有环
    fn check_for_cycles(&self) -> bool {
        let mut visited = HashSet::new();
        let mut recursion_stack = HashSet::new();
        
        for box_id in self.distribution_boxes.keys() {
            if !visited.contains(box_id) && 
               self.has_cycle_dfs(box_id, &mut visited, &mut recursion_stack) {
                return true;
            }
        }
        
        false
    }

    /// 深度优先搜索检查环
    fn has_cycle_dfs(&self, box_id: &str, visited: &mut HashSet<String>, 
                     recursion_stack: &mut HashSet<String>) -> bool {
        if !visited.contains(box_id) {
            visited.insert(box_id.to_string());
            recursion_stack.insert(box_id.to_string());
            
            if let Some(children) = self.hierarchy_map.get(box_id) {
                for child_id in children {
                    if !visited.contains(child_id) && 
                       self.has_cycle_dfs(child_id, visited, recursion_stack) {
                        return true;
                    } else if recursion_stack.contains(child_id) {
                        return true;
                    }
                }
            }
        }
        
        recursion_stack.remove(box_id);
        false
    }
}

/// 拓扑分析结果
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TopologyAnalysisResult {
    pub total_boxes: usize,             // 总配电箱数量
    pub total_connections: usize,       // 总连接数量
    pub root_boxes: Vec<String>,        // 根配电箱列表
    pub leaf_boxes: Vec<String>,        // 叶子配电箱列表
    pub has_cycles: bool,               // 是否有环
    pub isolated_boxes: Vec<String>,    // 孤立配电箱列表
}

impl Default for TrunkSystemData {
    fn default() -> Self {
        Self::new("default_system".to_string(), "默认干线系统".to_string())
    }
}
```

## 四、数据管理器定义

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

/// 数据管理器 - 用于管理整个系统的数据
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DataManager {
    pub circuits: HashMap<String, CircuitData>,               // 回路数据映射
    pub distribution_boxes: HashMap<String, DistributionBoxData>, // 配电箱数据映射
    pub trunk_systems: HashMap<String, TrunkSystemData>,      // 干线系统数据映射
    pub change_callbacks: Vec<Box<dyn FnMut(&DataChange)>>,   // 数据变更回调
    pub last_change: Option<DataChange>,                      // 上次变更记录
}

/// 数据变更类型
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum DataChangeType {
    AddCircuit,
    UpdateCircuit,
    RemoveCircuit,
    AddDistributionBox,
    UpdateDistributionBox,
    RemoveDistributionBox,
    AddTrunkSystem,
    UpdateTrunkSystem,
    RemoveTrunkSystem,
}

/// 数据变更记录
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DataChange {
    pub change_type: DataChangeType,  // 变更类型
    pub entity_id: String,            // 实体ID
    pub timestamp: u64,               // 变更时间戳
    pub details: Option<String>,      // 变更详情
}

impl DataManager {
    /// 创建新的数据管理器
    pub fn new() -> Self {
        Self {
            circuits: HashMap::new(),
            distribution_boxes: HashMap::new(),
            trunk_systems: HashMap::new(),
            change_callbacks: Vec::new(),
            last_change: None,
        }
    }

    /// 添加变更回调
    pub fn add_change_callback(&mut self, callback: Box<dyn FnMut(&DataChange)>) {
        self.change_callbacks.push(callback);
    }

    /// 触发数据变更
    fn trigger_change(&mut self, change_type: DataChangeType, entity_id: String, details: Option<String>) {
        let change = DataChange {
            change_type,
            entity_id,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            details,
        };
        
        self.last_change = Some(change.clone());
        
        // 触发所有回调
        for callback in &mut self.change_callbacks {
            callback(&change);
        }
    }

    /// 保存数据一致性
    pub fn ensure_consistency(&mut self) {
        // 确保所有回路都属于某个配电箱
        let mut circuit_ids_in_boxes = HashSet::new();
        
        // 收集所有配电箱中的回路ID
        for box_data in self.distribution_boxes.values() {
            // 进线回路
            if let Some(incoming) = &box_data.incoming_circuit {
                circuit_ids_in_boxes.insert(format!("{}_incoming", box_data.id));
            }
            
            // 出线回路
            for circuit_num in box_data.circuits.keys() {
                circuit_ids_in_boxes.insert(format!("{}_{}", box_data.id, circuit_num.number));
            }
        }
        
        // 收集所有干线系统中的回路ID
        for system in self.trunk_systems.values() {
            if let Some(incoming) = &system.incoming_circuit {
                circuit_ids_in_boxes.insert(format!("{}_incoming", system.system_id));
            }
            
            // 连接回路
            for connection in &system.connections {
                circuit_ids_in_boxes.insert(format!("{}_{}", 
                    connection.from_box_id, connection.circuit_number.number));
            }
        }
        
        // 清理不属于任何配电箱的回路
        let mut circuits_to_remove = Vec::new();
        for circuit_id in self.circuits.keys() {
            if !circuit_ids_in_boxes.contains(circuit_id) {
                circuits_to_remove.push(circuit_id.clone());
            }
        }
        
        for circuit_id in circuits_to_remove {
            self.circuits.remove(&circuit_id);
        }
        
        // 确保所有配电箱都属于某个干线系统
        let mut box_ids_in_systems = HashSet::new();
        
        for system in self.trunk_systems.values() {
            for box_id in system.distribution_boxes.keys() {
                box_ids_in_systems.insert(box_id.clone());
            }
        }
        
        // 清理不属于任何干线系统的配电箱
        let mut boxes_to_remove = Vec::new();
        for box_id in self.distribution_boxes.keys() {
            if !box_ids_in_systems.contains(box_id) {
                boxes_to_remove.push(box_id.clone());
            }
        }
        
        for box_id in boxes_to_remove {
            self.distribution_boxes.remove(&box_id);
        }
    }

    /// 批量导入数据
    pub fn import_data(&mut self, circuits: Vec<CircuitData>, 
                      boxes: Vec<DistributionBoxData>, 
                      systems: Vec<TrunkSystemData>) {
        // 清空现有数据
        self.circuits.clear();
        self.distribution_boxes.clear();
        self.trunk_systems.clear();
        
        // 导入干线系统（先导入，因为它包含其他数据）
        for system in systems {
            self.trunk_systems.insert(system.system_id.clone(), system);
            self.trigger_change(
                DataChangeType::AddTrunkSystem,
                system.system_id.clone(),
                Some("批量导入".to_string())
            );
        }
        
        // 导入配电箱
        for box_data in boxes {
            self.distribution_boxes.insert(box_data.id.clone(), box_data);
            self.trigger_change(
                DataChangeType::AddDistributionBox,
                box_data.id.clone(),
                Some("批量导入".to_string())
            );
        }
        
        // 导入回路
        for circuit in circuits {
            let circuit_id = format!("{}_{}", circuit.circuit_number.number, circuit.circuit_name);
            self.circuits.insert(circuit_id.clone(), circuit);
            self.trigger_change(
                DataChangeType::AddCircuit,
                circuit_id,
                Some("批量导入".to_string())
            );
        }
        
        // 确保数据一致性
        self.ensure_consistency();
    }
}

impl Default for DataManager {
    fn default() -> Self {
        Self::new()
    }
}
```

## 五、数据结构集成方案

### 1. ElectricValueType 与 CircuitData 的集成

```rust
// 将 CircuitData 转换为 ElectricValueType 字典
impl From<&CircuitData> for HashMap<String, ElectricValueType> {
    fn from(circuit: &CircuitData) -> Self {
        let mut map = HashMap::new();
        
        // 基本信息
        map.insert("circuit_number".to_string(), 
                  ElectricValueType::Integer(circuit.circuit_number.number as i64));
        map.insert("circuit_name".to_string(), 
                  ElectricValueType::String(circuit.circuit_name.clone()));
        map.insert("rated_power".to_string(), 
                  ElectricValueType::Float(circuit.rated_power));
        map.insert("demand_coefficient".to_string(), 
                  ElectricValueType::Float(circuit.demand_coefficient));
        map.insert("power_factor".to_string(), 
                  ElectricValueType::Float(circuit.power_factor));
        map.insert("calculated_current".to_string(), 
                  ElectricValueType::Float(circuit.calculated_current));
        map.insert("circuit_purpose".to_string(), 
                  ElectricValueType::String(circuit.circuit_purpose.to_str().to_string()));
        map.insert("phase_sequence".to_string(), 
                  ElectricValueType::String(circuit.phase_sequence.to_str().to_string()));
        
        // 相位信息
        if let Some(phase) = &circuit.phase {
            match phase {
                Phase::L1 => map.insert("phase".to_string(), 
                                      ElectricValueType::String("L1".to_string())),
                Phase::L2 => map.insert("phase".to_string(), 
                                      ElectricValueType::String("L2".to_string())),
                Phase::L3 => map.insert("phase".to_string(), 
                                      ElectricValueType::String("L3".to_string())),
                Phase::ThreePhase => map.insert("phase".to_string(), 
                                              ElectricValueType::String("ThreePhase".to_string())),
            };
        }
        
        // 线缆信息
        map.insert("cable_model".to_string(), 
                  ElectricValueType::String(circuit.cable_info.model.clone()));
        map.insert("cable_size".to_string(), 
                  ElectricValueType::String(circuit.cable_info.size.clone()));
        
        // 元器件信息
        if let Some(breaker) = circuit.get_breaker() {
            map.insert("breaker_model".to_string(), 
                      ElectricValueType::String(breaker.model.clone()));
            map.insert("breaker_rated_current".to_string(), 
                      ElectricValueType::Float(breaker.rated_current.to_f64()));
        }
        
        map
    }
}
```

### 2. ElectricValueType 与 DistributionBoxData 的集成

```rust
// 将 DistributionBoxData 转换为 ElectricValueType 字典
impl From<&DistributionBoxData> for HashMap<String, ElectricValueType> {
    fn from(box_data: &DistributionBoxData) -> Self {
        let mut map = HashMap::new();
        
        // 基本信息
        map.insert("id".to_string(), 
                  ElectricValueType::String(box_data.id.clone()));
        map.insert("name".to_string(), 
                  ElectricValueType::String(box_data.name.clone()));
        map.insert("model".to_string(), 
                  ElectricValueType::String(box_data.model.clone()));
        map.insert("width".to_string(), 
                  ElectricValueType::Float(box_data.frame_size.0));
        map.insert("height".to_string(), 
                  ElectricValueType::Float(box_data.frame_size.1));
        
        // 总负荷信息
        map.insert("total_rated_power".to_string(), 
                  ElectricValueType::Float(box_data.load_total.total_rated_power));
        map.insert("total_calculated_power".to_string(), 
                  ElectricValueType::Float(box_data.load_total.total_calculated_power));
        map.insert("total_current".to_string(), 
                  ElectricValueType::Float(box_data.load_total.total_current));
        map.insert("utilization_rate".to_string(), 
                  ElectricValueType::Float(box_data.load_total.utilization_rate));
        
        // 三相平衡信息
        map.insert("l1_current".to_string(), 
                  ElectricValueType::Float(box_data.three_phase_balance_info.l1_current));
        map.insert("l2_current".to_string(), 
                  ElectricValueType::Float(box_data.three_phase_balance_info.l2_current));
        map.insert("l3_current".to_string(), 
                  ElectricValueType::Float(box_data.three_phase_balance_info.l3_current));
        map.insert("unbalance_rate".to_string(), 
                  ElectricValueType::Float(box_data.three_phase_balance_info.unbalance_rate));
        map.insert("balance_status".to_string(), 
                  ElectricValueType::String(box_data.three_phase_balance_info.balance_status.clone()));
        
        // 回路数量
        map.insert("circuit_count".to_string(), 
                  ElectricValueType::Integer(box_data.circuits.len() as i64));
        
        map
    }
}
```

### 3. ElectricValueType 与 TrunkSystemData 的集成

```rust
// 将 TrunkSystemData 转换为 ElectricValueType 字典
impl From<&TrunkSystemData> for HashMap<String, ElectricValueType> {
    fn from(system: &TrunkSystemData) -> Self {
        let mut map = HashMap::new();
        
        // 基本信息
        map.insert("system_id".to_string(), 
                  ElectricValueType::String(system.system_id.clone()));
        map.insert("system_name".to_string(), 
                  ElectricValueType::String(system.system_name.clone()));
        map.insert("voltage_level".to_string(), 
                  ElectricValueType::String(system.voltage_level.to_str().to_string()));
        
        // 系统组成信息
        map.insert("distribution_box_count".to_string(), 
                  ElectricValueType::Integer(system.distribution_boxes.len() as i64));
        map.insert("connection_count".to_string(), 
                  ElectricValueType::Integer(system.connections.len() as i64));
        
        // 系统类型
        let system_type_str = match system.system_type {
            SystemType::Radial => "放射式",
            SystemType::树干式 => "树干式",
            SystemType::Ring => "环式",
            SystemType::Hybrid => "混合式",
        };
        map.insert("system_type".to_string(), 
                  ElectricValueType::String(system_type_str.to_string()));
        
        map
    }
}
```

## 六、注意事项

1. **数据一致性**：DataManager 提供了 ensure_consistency 方法来确保数据之间的引用关系正确，避免出现孤立的数据实体。

2. **变更追踪**：系统实现了完整的变更追踪机制，可以通过注册回调函数来响应数据变更事件。

3. **批量操作**：提供了批量导入功能，方便一次性导入大量数据。

4. **拓扑分析**：TrunkSystemData 提供了完整的拓扑分析功能，可以分析系统的层级结构、检测环和孤立节点等。

5. **三相平衡优化**：DistributionBoxData 提供了自动优化三相平衡的功能，可以根据当前各相负荷情况，智能调整回路分配。

6. **扩展性**：数据结构设计考虑了良好的扩展性，可以方便地添加新的字段和功能。

7. **类型安全**：使用 Rust 的类型系统确保数据的类型安全，避免运行时类型错误。

8. **序列化支持**：所有数据结构都实现了 Serialize 和 Deserialize 特性，支持 JSON 序列化和反序列化，方便数据存储和传输。