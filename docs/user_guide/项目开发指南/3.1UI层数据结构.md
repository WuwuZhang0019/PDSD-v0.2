# 03UI层数据结构定义方案

## 一、概述

本文档定义了UI层（特别是节点编辑器部分）的数据结构，旨在与业务层数据结构保持一致性的同时，满足egui_node_graph库的接口要求。UI层数据结构将作为业务层与节点编辑器之间的适配器，确保两者能够无缝交互。

## 二、核心数据结构定义

### 2.1 UI层值类型 (UIValueType)

```rust
use serde::{Deserialize, Serialize};
use egui_node_graph::{NodeId, NodeResponse};
use std::borrow::Cow;

/// UI层的值类型枚举，用于节点编辑器中表示不同类型的数据值
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum UIValueType {
    Float(f64),              // 浮点数（用于电流、功率等）
    Integer(i64),            // 整数（用于标识、数量等）
    String(String),          // 字符串（用于文本信息）
    CircuitInfo(CircuitInfo), // 简化的回路信息
    DistributionBoxInfo(DistributionBoxInfo), // 简化的配电箱信息
    PhaseBalanceInfo(PhaseBalanceInfo), // 三相平衡信息
}

/// 实现Default特性，满足WidgetValueTrait的约束要求
impl Default for UIValueType {
    fn default() -> Self {
        UIValueType::Float(0.0)
    }
}

/// 实现WidgetValueTrait，为节点编辑器提供自定义UI组件
impl WidgetValueTrait for UIValueType {
    type Response = UIResponse;
    type UserState = UIUserState;
    type NodeData = ElectricNodeData;

    fn value_widget(
        &mut self,
        param_name: &str,
        node_id: NodeId,
        ui: &mut egui::Ui,
        user_state: &mut Self::UserState,
        node_data: &Self::NodeData,
    ) -> Vec<Self::Response> {
        let mut responses = Vec::new();
        
        match self {
            UIValueType::Float(value) => {
                let mut val = *value;
                if ui.add(egui::Slider::new(&mut val, 0.0..=1000.0).text(param_name)).changed() {
                    *value = val;
                    responses.push(UIResponse::ValueChanged(node_id, param_name.to_string(), UIValueType::Float(val)));
                }
            },
            UIValueType::Integer(value) => {
                let mut val = *value;
                if ui.add(egui::DragValue::new(&mut val).label(param_name)).changed() {
                    *value = val;
                    responses.push(UIResponse::ValueChanged(node_id, param_name.to_string(), UIValueType::Integer(val)));
                }
            },
            UIValueType::String(value) => {
                let mut val = value.clone();
                if ui.add(egui::TextEdit::singleline(&mut val).label(param_name)).changed() {
                    *value = val.clone();
                    responses.push(UIResponse::ValueChanged(node_id, param_name.to_string(), UIValueType::String(val)));
                }
            },
            UIValueType::CircuitInfo(circuit_info) => {
                ui.collapsing(param_name, |ui| {
                    let mut id = circuit_info.id.clone();
                    if ui.add(egui::TextEdit::singleline(&mut id).label("回路编号")).changed() {
                        circuit_info.id = id.clone();
                        responses.push(UIResponse::CircuitInfoUpdated(node_id, circuit_info.clone()));
                    }
                    
                    let mut name = circuit_info.name.clone();
                    if ui.add(egui::TextEdit::singleline(&mut name).label("回路名称")).changed() {
                        circuit_info.name = name.clone();
                        responses.push(UIResponse::CircuitInfoUpdated(node_id, circuit_info.clone()));
                    }
                    
                    let mut power = circuit_info.power;
                    if ui.add(egui::Slider::new(&mut power, 0.0..=100.0).text("功率(kW)")).changed() {
                        circuit_info.power = power;
                        responses.push(UIResponse::CircuitInfoUpdated(node_id, circuit_info.clone()));
                    }
                    
                    let mut phase = circuit_info.phase;
                    egui::ComboBox::from_label("相序")
                        .selected_text(format!("{:?}", phase))
                        .show_ui(ui, |ui| {
                            ui.selectable_value(&mut phase, "L1", "L1");
                            ui.selectable_value(&mut phase, "L2", "L2");
                            ui.selectable_value(&mut phase, "L3", "L3");
                            ui.selectable_value(&mut phase, "三相", "三相");
                        });
                    if phase != circuit_info.phase {
                        circuit_info.phase = phase;
                        responses.push(UIResponse::CircuitInfoUpdated(node_id, circuit_info.clone()));
                    }
                });
            },
            UIValueType::DistributionBoxInfo(box_info) => {
                ui.collapsing(param_name, |ui| {
                    let mut id = box_info.id.clone();
                    if ui.add(egui::TextEdit::singleline(&mut id).label("箱编号")).changed() {
                        box_info.id = id.clone();
                        responses.push(UIResponse::DistributionBoxInfoUpdated(node_id, box_info.clone()));
                    }
                    
                    let mut name = box_info.name.clone();
                    if ui.add(egui::TextEdit::singleline(&mut name).label("箱名称")).changed() {
                        box_info.name = name.clone();
                        responses.push(UIResponse::DistributionBoxInfoUpdated(node_id, box_info.clone()));
                    }
                    
                    ui.label(format!("回路数量: {}", box_info.circuit_count));
                    ui.label(format!("总功率: {:.2} kW", box_info.total_power));
                });
            },
            UIValueType::PhaseBalanceInfo(balance_info) => {
                ui.collapsing(param_name, |ui| {
                    ui.label(format!("A相负载: {:.2} kW", balance_info.phase_a));
                    ui.label(format!("B相负载: {:.2} kW", balance_info.phase_b));
                    ui.label(format!("C相负载: {:.2} kW", balance_info.phase_c));
                    ui.label(format!("平衡度: {:.2}%", balance_info.balance_degree));
                });
            },
        }
        
        responses
    }
}
```

### 2.2 简化的回路信息结构 (CircuitInfo)

```rust
/// 简化的回路信息结构，用于UI层显示和编辑
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CircuitInfo {
    pub id: String,          // 回路编号
    pub name: String,        // 回路名称
    pub power: f64,          // 功率(kW)
    pub phase: String,       // 相序
    pub circuit_type: String,// 回路类型
    pub current: f64,        // 计算电流(A)
}

impl Default for CircuitInfo {
    fn default() -> Self {
        Self {
            id: "WL1".to_string(),
            name: "默认回路".to_string(),
            power: 1.0,
            phase: "L1".to_string(),
            circuit_type: "照明".to_string(),
            current: 0.0,
        }
    }
}
```

### 2.3 简化的配电箱信息结构 (DistributionBoxInfo)

```rust
/// 简化的配电箱信息结构，用于UI层显示和编辑
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DistributionBoxInfo {
    pub id: String,          // 配电箱编号
    pub name: String,        // 配电箱名称
    pub box_type: String,    // 配电箱类型
    pub circuit_count: usize,// 回路数量
    pub total_power: f64,    // 总功率(kW)
    pub calculated_current: f64, // 计算电流(A)
    pub phase_a_load: f64,   // A相负载(kW)
    pub phase_b_load: f64,   // B相负载(kW)
    pub phase_c_load: f64,   // C相负载(kW)
}

impl Default for DistributionBoxInfo {
    fn default() -> Self {
        Self {
            id: "MDB-001".to_string(),
            name: "照明配电箱".to_string(),
            box_type: "户内嵌入式".to_string(),
            circuit_count: 0,
            total_power: 0.0,
            calculated_current: 0.0,
            phase_a_load: 0.0,
            phase_b_load: 0.0,
            phase_c_load: 0.0,
        }
    }
}
```

### 2.4 三相平衡信息结构 (PhaseBalanceInfo)

```rust
/// 三相平衡信息结构，用于UI层显示
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PhaseBalanceInfo {
    pub phase_a: f64,        // A相负载(kW)
    pub phase_b: f64,        // B相负载(kW)
    pub phase_c: f64,        // C相负载(kW)
    pub balance_degree: f64, // 平衡度百分比
}

impl Default for PhaseBalanceInfo {
    fn default() -> Self {
        Self {
            phase_a: 0.0,
            phase_b: 0.0,
            phase_c: 0.0,
            balance_degree: 0.0,
        }
    }
}
```

### 2.5 数据类型定义 (DataType)

```rust
/// 数据类型定义，用于节点编辑器中标识不同的数据类型
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DataType {
    Float,                  // 浮点数类型
    Integer,                // 整数类型
    String,                 // 字符串类型
    CircuitInfo,            // 回路信息类型
    DistributionBoxInfo,    // 配电箱信息类型
    PhaseBalanceInfo,       // 三相平衡信息类型
}

impl DataTypeTrait<UIUserState> for DataType {
    fn data_type_color(&self, _user_state: &mut UIUserState) -> egui::Color32 {
        match self {
            DataType::Float => egui::Color32::from_rgb(79, 146, 255),
            DataType::Integer => egui::Color32::from_rgb(80, 250, 123),
            DataType::String => egui::Color32::from_rgb(255, 184, 108),
            DataType::CircuitInfo => egui::Color32::from_rgb(255, 85, 85),
            DataType::DistributionBoxInfo => egui::Color32::from_rgb(189, 147, 249),
            DataType::PhaseBalanceInfo => egui::Color32::from_rgb(241, 250, 140),
        }
    }
    
    fn name(&self) -> Cow<str> {
        match self {
            DataType::Float => Cow::Borrowed("数值"),
            DataType::Integer => Cow::Borrowed("整数"),
            DataType::String => Cow::Borrowed("文本"),
            DataType::CircuitInfo => Cow::Borrowed("回路信息"),
            DataType::DistributionBoxInfo => Cow::Borrowed("配电箱信息"),
            DataType::PhaseBalanceInfo => Cow::Borrowed("三相平衡"),
        }
    }
}
```

### 2.6 节点数据类型 (ElectricNodeData)

```rust
/// 电气节点数据类型，用于表示节点编辑器中的节点
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ElectricNodeData {
    pub node_type: ElectricNodeType, // 节点类型
    pub name: String,                // 节点名称
    pub description: String,         // 节点描述
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ElectricNodeType {
    CircuitNode,          // 回路节点
    DistributionBoxNode,  // 配电箱节点
    MainLineNode,         // 主线路节点
    CalculationNode,      // 计算节点
    InputNode,            // 输入节点
    OutputNode,           // 输出节点
}

impl Default for ElectricNodeData {
    fn default() -> Self {
        Self {
            node_type: ElectricNodeType::CircuitNode,
            name: "新节点".to_string(),
            description: "".to_string(),
        }
    }
}

impl NodeDataTrait for ElectricNodeData {
    type Response = UIResponse;
    type UserState = UIUserState;
    type DataType = DataType;
    type ValueType = UIValueType;
    
    fn bottom_ui(
        &self,
        ui: &mut egui::Ui,
        node_id: NodeId,
        _graph: &Graph<Self, Self::DataType, Self::ValueType>,
        user_state: &mut Self::UserState,
    ) -> Vec<NodeResponse<Self::Response, Self>> {
        let mut responses = Vec::new();
        
        // 根据节点类型显示不同的底部UI
        match self.node_type {
            ElectricNodeType::CircuitNode => {
                ui.label("回路节点");
            },
            ElectricNodeType::DistributionBoxNode => {
                ui.label("配电箱节点");
            },
            ElectricNodeType::MainLineNode => {
                ui.label("主线路节点");
            },
            ElectricNodeType::CalculationNode => {
                ui.label("计算节点");
            },
            ElectricNodeType::InputNode => {
                ui.label("输入节点");
            },
            ElectricNodeType::OutputNode => {
                ui.label("输出节点");
            },
        }
        
        responses
    }
    
    fn titlebar_color(
        &self,
        _ui: &egui::Ui,
        _node_id: NodeId,
        _graph: &Graph<Self, Self::DataType, Self::ValueType>,
        _user_state: &mut Self::UserState,
    ) -> Option<egui::Color32> {
        match self.node_type {
            ElectricNodeType::CircuitNode => Some(egui::Color32::from_rgb(255, 85, 85)),
            ElectricNodeType::DistributionBoxNode => Some(egui::Color32::from_rgb(189, 147, 249)),
            ElectricNodeType::MainLineNode => Some(egui::Color32::from_rgb(139, 232, 253)),
            ElectricNodeType::CalculationNode => Some(egui::Color32::from_rgb(255, 184, 108)),
            ElectricNodeType::InputNode => Some(egui::Color32::from_rgb(80, 250, 123)),
            ElectricNodeType::OutputNode => Some(egui::Color32::from_rgb(79, 146, 255)),
        }
    }
}
```

### 2.7 UI响应类型 (UIResponse)

```rust
/// UI响应类型，用于在UI操作后返回事件
#[derive(Debug, Clone)]
pub enum UIResponse {
    ValueChanged(NodeId, String, UIValueType),
    CircuitInfoUpdated(NodeId, CircuitInfo),
    DistributionBoxInfoUpdated(NodeId, DistributionBoxInfo),
    NodeSelected(NodeId),
    NodeDeleted(NodeId),
    ConnectionAdded(NodeId, String, NodeId, String),
    ConnectionRemoved(NodeId, String, NodeId, String),
}

impl UserResponseTrait for UIResponse {}
```

### 2.8 UI用户状态 (UIUserState)

```rust
/// UI用户状态，用于在节点编辑器操作期间存储临时状态
#[derive(Debug, Clone, Default)]
pub struct UIUserState {
    pub selected_node: Option<NodeId>,
    pub error_message: Option<String>,
    pub message_queue: Vec<String>,
    pub show_property_panel: bool,
    pub show_log_panel: bool,
    pub zoom_level: f32,
}
```

## 三、业务层与UI层数据转换

### 3.1 从业务层到UI层的转换

```rust
/// 从业务层CircuitData转换为UI层CircuitInfo
impl From<&CircuitData> for CircuitInfo {
    fn from(circuit_data: &CircuitData) -> Self {
        CircuitInfo {
            id: circuit_data.circuit_id.clone(),
            name: circuit_data.description.clone(),
            power: circuit_data.rated_power,
            phase: match circuit_data.phase_sequence {
                Phase::L1 => "L1",
                Phase::L2 => "L2",
                Phase::L3 => "L3",
                Phase::ThreePhase => "三相",
                _ => "L1",
            }.to_string(),
            circuit_type: circuit_data.circuit_type.clone(),
            current: circuit_data.calculated_current,
        }
    }
}

/// 从业务层DistributionBoxData转换为UI层DistributionBoxInfo
impl From<&DistributionBoxData> for DistributionBoxInfo {
    fn from(box_data: &DistributionBoxData) -> Self {
        DistributionBoxInfo {
            id: box_data.box_id.clone(),
            name: box_data.name.clone(),
            box_type: box_data.box_type.clone(),
            circuit_count: box_data.circuits.len(),
            total_power: box_data.rated_power,
            calculated_current: box_data.calculated_current,
            phase_a_load: box_data.phase_a_load,
            phase_b_load: box_data.phase_b_load,
            phase_c_load: box_data.phase_c_load,
        }
    }
}

/// 从业务层计算三相平衡信息
impl From<&DistributionBoxData> for PhaseBalanceInfo {
    fn from(box_data: &DistributionBoxData) -> Self {
        let balance_degree = box_data.get_balance_degree();
        PhaseBalanceInfo {
            phase_a: box_data.phase_a_load,
            phase_b: box_data.phase_b_load,
            phase_c: box_data.phase_c_load,
            balance_degree,
        }
    }
}
```

### 3.2 从UI层到业务层的转换

```rust
/// 从UI层CircuitInfo更新业务层CircuitData
pub fn update_circuit_data_from_ui(circuit_data: &mut CircuitData, circuit_info: &CircuitInfo) {
    circuit_data.circuit_id = circuit_info.id.clone();
    circuit_data.description = circuit_info.name.clone();
    circuit_data.rated_power = circuit_info.power;
    circuit_data.phase_sequence = match circuit_info.phase.as_str() {
        "L1" => Phase::L1,
        "L2" => Phase::L2,
        "L3" => Phase::L3,
        "三相" => Phase::ThreePhase,
        _ => Phase::L1,
    };
    circuit_data.circuit_type = circuit_info.circuit_type.clone();
    // 注意：calculated_current应该通过业务层的计算方法更新，而不是直接赋值
}

/// 从UI层DistributionBoxInfo更新业务层DistributionBoxData
pub fn update_box_data_from_ui(box_data: &mut DistributionBoxData, box_info: &DistributionBoxInfo) {
    box_data.box_id = box_info.id.clone();
    box_data.name = box_info.name.clone();
    box_data.box_type = box_info.box_type.clone();
    // 注意：circuit_count、total_power、calculated_current等应由业务层计算，而不是直接赋值
}
```

## 四、节点模板定义

### 4.1 电气节点模板 (ElectricNodeTemplate)

```rust
/// 电气节点模板，用于创建不同类型的节点
#[derive(Debug, Clone)]
pub enum ElectricNodeTemplate {
    CircuitNodeTemplate,
    DistributionBoxNodeTemplate,
    MainLineNodeTemplate,
    CalculationNodeTemplate,
    InputNodeTemplate,
    OutputNodeTemplate,
}

impl NodeTemplateTrait for ElectricNodeTemplate {
    type NodeData = ElectricNodeData;
    type DataType = DataType;
    type ValueType = UIValueType;
    type UserState = UIUserState;
    type CategoryType = &'static str;
    
    fn node_finder_label(&self, _user_state: &mut Self::UserState) -> Cow<str> {
        match self {
            ElectricNodeTemplate::CircuitNodeTemplate => Cow::Borrowed("回路节点"),
            ElectricNodeTemplate::DistributionBoxNodeTemplate => Cow::Borrowed("配电箱节点"),
            ElectricNodeTemplate::MainLineNodeTemplate => Cow::Borrowed("主线路节点"),
            ElectricNodeTemplate::CalculationNodeTemplate => Cow::Borrowed("计算节点"),
            ElectricNodeTemplate::InputNodeTemplate => Cow::Borrowed("输入节点"),
            ElectricNodeTemplate::OutputNodeTemplate => Cow::Borrowed("输出节点"),
        }
    }
    
    fn node_finder_categories(&self, _user_state: &mut Self::UserState) -> Vec<Self::CategoryType> {
        match self {
            ElectricNodeTemplate::CircuitNodeTemplate => vec!["基本", "回路"],
            ElectricNodeTemplate::DistributionBoxNodeTemplate => vec!["基本", "配电箱"],
            ElectricNodeTemplate::MainLineNodeTemplate => vec!["基本", "线路"],
            ElectricNodeTemplate::CalculationNodeTemplate => vec!["计算"],
            ElectricNodeTemplate::InputNodeTemplate => vec!["数据流"],
            ElectricNodeTemplate::OutputNodeTemplate => vec!["数据流"],
        }
    }
    
    fn node_graph_label(&self, _user_state: &mut Self::UserState) -> String {
        self.node_finder_label(_user_state).into_owned()
    }
    
    fn user_data(&self, _user_state: &mut Self::UserState) -> Self::NodeData {
        match self {
            ElectricNodeTemplate::CircuitNodeTemplate => ElectricNodeData {
                node_type: ElectricNodeType::CircuitNode,
                name: "回路节点".to_string(),
                description: "用于表示配电回路的节点".to_string(),
            },
            ElectricNodeTemplate::DistributionBoxNodeTemplate => ElectricNodeData {
                node_type: ElectricNodeType::DistributionBoxNode,
                name: "配电箱节点".to_string(),
                description: "用于表示配电箱的节点".to_string(),
            },
            ElectricNodeTemplate::MainLineNodeTemplate => ElectricNodeData {
                node_type: ElectricNodeType::MainLineNode,
                name: "主线路节点".to_string(),
                description: "用于表示主线路的节点".to_string(),
            },
            ElectricNodeTemplate::CalculationNodeTemplate => ElectricNodeData {
                node_type: ElectricNodeType::CalculationNode,
                name: "计算节点".to_string(),
                description: "用于进行电气计算的节点".to_string(),
            },
            ElectricNodeTemplate::InputNodeTemplate => ElectricNodeData {
                node_type: ElectricNodeType::InputNode,
                name: "输入节点".to_string(),
                description: "用于输入数据的节点".to_string(),
            },
            ElectricNodeTemplate::OutputNodeTemplate => ElectricNodeData {
                node_type: ElectricNodeType::OutputNode,
                name: "输出节点".to_string(),
                description: "用于输出数据的节点".to_string(),
            },
        }
    }
    
    fn build_node(
        &self,
        graph: &mut Graph<Self::NodeData, Self::DataType, Self::ValueType>,
        _user_state: &mut Self::UserState,
        node_id: NodeId,
    ) {
        match self {
            ElectricNodeTemplate::CircuitNodeTemplate => {
                // 添加回路节点的输入参数
                graph.add_input_param(
                    node_id,
                    "回路信息",
                    DataType::CircuitInfo,
                    UIValueType::CircuitInfo(CircuitInfo::default()),
                );
                
                // 添加回路节点的输出参数
                graph.add_output_param(
                    node_id,
                    "回路信息输出",
                    DataType::CircuitInfo,
                );
            },
            ElectricNodeTemplate::DistributionBoxNodeTemplate => {
                // 添加配电箱节点的输入参数
                graph.add_input_param(
                    node_id,
                    "配电箱信息",
                    DataType::DistributionBoxInfo,
                    UIValueType::DistributionBoxInfo(DistributionBoxInfo::default()),
                );
                
                // 添加配电箱节点的输出参数
                graph.add_output_param(
                    node_id,
                    "配电箱信息输出",
                    DataType::DistributionBoxInfo,
                );
                graph.add_output_param(
                    node_id,
                    "三相平衡信息",
                    DataType::PhaseBalanceInfo,
                );
            },
            // 其他节点类型的参数设置...
            _ => {},
        }
    }
}
```

## 五、使用示例

### 5.1 初始化节点编辑器

```rust
fn init_node_editor() -> GraphEditorState<
    ElectricNodeData,
    DataType,
    UIValueType,
    UIResponse,
    UIUserState,
    ElectricNodeTemplate,
> {
    let mut state = GraphEditorState::new();
    let mut user_state = UIUserState::default();
    
    // 添加节点模板
    let templates = vec![
        ElectricNodeTemplate::CircuitNodeTemplate,
        ElectricNodeTemplate::DistributionBoxNodeTemplate,
        ElectricNodeTemplate::MainLineNodeTemplate,
        ElectricNodeTemplate::CalculationNodeTemplate,
        ElectricNodeTemplate::InputNodeTemplate,
        ElectricNodeTemplate::OutputNodeTemplate,
    ];
    
    // 注册节点模板
    for template in templates {
        state.add_node_template(template);
    }
    
    state
}
```

### 5.2 业务数据与UI数据的同步

```rust
fn sync_business_data_with_ui(
    business_data: &mut BusinessData,
    ui_state: &Graph<ElectricNodeData, DataType, UIValueType>,
) {
    // 遍历所有节点，同步数据
    for node_id in ui_state.all_nodes() {
        if let Some(node_data) = ui_state.node_data(node_id) {
            match node_data.node_type {
                ElectricNodeType::CircuitNode => {
                    // 处理回路节点数据同步
                    if let Some(param_value) = ui_state.param_value(node_id, "回路信息") {
                        if let UIValueType::CircuitInfo(circuit_info) = param_value {
                            // 查找对应的业务层数据并更新
                            if let Some(circuit_data) = business_data.find_circuit_by_id(&circuit_info.id) {
                                update_circuit_data_from_ui(circuit_data, circuit_info);
                            }
                        }
                    }
                },
                ElectricNodeType::DistributionBoxNode => {
                    // 处理配电箱节点数据同步
                    if let Some(param_value) = ui_state.param_value(node_id, "配电箱信息") {
                        if let UIValueType::DistributionBoxInfo(box_info) = param_value {
                            // 查找对应的业务层数据并更新
                            if let Some(box_data) = business_data.find_box_by_id(&box_info.id) {
                                update_box_data_from_ui(box_data, box_info);
                            }
                        }
                    }
                },
                _ => {},
            }
        }
    }
}
```

## 六、注意事项

1. **数据一致性维护**：UI层数据结构是业务层数据结构的简化版本，主要用于显示和交互。业务逻辑的计算和验证应始终在业务层进行，UI层只负责数据的呈现和用户输入的收集。

2. **双向转换**：确保UI层和业务层之间的数据转换是双向且完整的，避免数据丢失。

3. **性能优化**：对于大型数据集，考虑使用懒加载或分页显示，避免一次性加载过多数据导致UI响应缓慢。

4. **错误处理**：在数据转换过程中，应妥善处理可能的错误情况，如数据不匹配、缺失字段等。

5. **扩展性设计**：UI层数据结构应设计得具有良好的扩展性，以便于未来添加新的节点类型和数据类型。

6. **与egui_node_graph的兼容性**：确保所有数据结构都正确实现了egui_node_graph库所需的trait，特别是WidgetValueTrait、DataTypeTrait和NodeDataTrait。