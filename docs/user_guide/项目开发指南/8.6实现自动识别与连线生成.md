为干线系统图节点添加自动识别配电箱进线类型和生成连线的功能：

````rust
impl DistributionBoxNodeData {
    // 判断进线类型
    fn determine_incoming_type(&self) -> IncomingType {
        if self.modules.contains(&"双电源切换".to_string()) {
            IncomingType::DualPower
        } else {
            IncomingType::SinglePower
        }
    }
}

enum IncomingType {
    SinglePower,
    DualPower,
}

impl MainSystemNodeData {
    // 根据进线类型自动生成连线
    fn auto_generate_connections(&self, boxes: &[DistributionBoxNodeData]) -> Vec<ConnectionInfo> {
        let mut connections = Vec::new();

        // 1. 按楼层排序配电箱
        let mut sorted_boxes = boxes.to_vec();
        sorted_boxes.sort_by(|a, b| a.floor.cmp(&b.floor));

        // 2. 生成连线
        let mut previous_boxes: Vec<&DistributionBoxNodeData> = Vec::new();

        for box_node in &sorted_boxes {
            // 确定父配电箱（通常是上一楼层的配电箱）
            if let Some(parent_box) = previous_boxes.iter()
                .filter(|b| b.floor < box_node.floor)
                .max_by_key(|b| b.floor) {

                // 根据进线类型生成连线
                let incoming_type = box_node.determine_incoming_type();

                connections.push(ConnectionInfo {
                    from: parent_box.name.clone(),
                    to: box_node.name.clone(),
                    connection_type: match incoming_type {
                        IncomingType::SinglePower => ConnectionType::SinglePower,
                        IncomingType::DualPower => ConnectionType::DualPower,
                    },
                });

                // 如果是双电源，还需要连接备用电源
                if let IncomingType::DualPower = incoming_type {
                    connections.push(ConnectionInfo {
                        from: "备用电源".to_string(),
                        to: box_node.name.clone(),
                        connection_type: ConnectionType::BackupPower,
                    });
                }
            }

            previous_boxes.push(box_node);
        }

        connections
    }
}

struct ConnectionInfo {
    from: String,
    to: String,
    connection_type: ConnectionType,
}

enum ConnectionType {
    SinglePower,
    DualPower,
    BackupPower,
    // 其他连接类型...
}

## 5. 完整应用示例

以下是一个基于本指南构建的简单电气节点图应用的完整示例代码，展示了如何将所有组件整合在一起：

```rust
use eframe::egui;
use egui_node_graph::{Graph, NodeTemplateTrait, DataTypeTrait, NodeResponse};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

// 1. 定义数据类型
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum ElectricDataType {
    Current,    // 电流(A)
    Power,      // 功率(kW)
    Voltage,    // 电压(V)
    PowerFactor,
}

impl DataTypeTrait for ElectricDataType {
    fn data_type_color(&self) -> egui::Color32 {
        match self {
            Self::Current => egui::Color32::RED,
            Self::Power => egui::Color32::GREEN,
            Self::Voltage => egui::Color32::BLUE,
            Self::PowerFactor => egui::Color32::YELLOW,
        }
    }

    fn data_type_name(&self) -> &str {
        match self {
            Self::Current => "电流(A)",
            Self::Power => "功率(kW)",
            Self::Voltage => "电压(V)",
            Self::PowerFactor => "功率因数",
        }
    }
}

// 2. 定义值类型
#[derive(Debug, Clone, PartialEq)]
enum ElectricValueType {
    Float(f64),
    String(String),
}

// 3. 定义节点数据
#[derive(Debug, Clone)]
enum ElectricNodeData {
    CircuitNode { name: String, power: f64, current: f64 },
    DistributionBoxNode { name: String, total_current: f64 },
    PowerSourceNode { name: String, voltage: f64 },
}

// 4. 定义节点模板
#[derive(Debug, Clone, PartialEq)]
enum ElectricNodeTemplate {
    CircuitNode,
    DistributionBoxNode,
    PowerSourceNode,
}

impl NodeTemplateTrait for ElectricNodeTemplate {
    type NodeData = ElectricNodeData;
    type DataType = ElectricDataType;
    type ValueType = ElectricValueType;

    fn node_type_name(&self) -> &str {
        match self {
            Self::CircuitNode => "配电回路",
            Self::DistributionBoxNode => "配电箱",
            Self::PowerSourceNode => "电源",
        }
    }

    fn node_template_category(&self) -> String {
        match self {
            Self::CircuitNode => "配电回路",
            Self::DistributionBoxNode => "配电箱",
            Self::PowerSourceNode => "电源",
        }
    }

    fn node_template_outputs(&self) -> Vec<(String, Self::DataType)> {
        match self {
            Self::CircuitNode => vec![("电流输出".to_string(), Self::DataType::Current)],
            Self::DistributionBoxNode => vec![("总电流".to_string(), Self::DataType::Current)],
            Self::PowerSourceNode => vec![("电压输出".to_string(), Self::DataType::Voltage)],
        }
    }

    fn node_template_inputs(&self) -> Vec<(String, Self::DataType)> {
        match self {
            Self::CircuitNode => vec![("电压输入".to_string(), Self::DataType::Voltage)],
            Self::DistributionBoxNode => vec![],
            Self::PowerSourceNode => vec![],
        }
    }

    fn node_template_params(&self) -> Vec<(String, Self::ValueType)> {
        match self {
            Self::CircuitNode => vec![("额定功率(kW)".to_string(), Self::ValueType::Float(10.0))],
            Self::DistributionBoxNode => vec![],
            Self::PowerSourceNode => vec![("电压值(V)".to_string(), Self::ValueType::Float(220.0))],
        }
    }

    fn construct_node_data(&self, params: &HashMap<String, Self::ValueType>) -> Self::NodeData {
        match self {
            Self::CircuitNode => {
                let power = params.get("额定功率(kW)").and_then(|v| {
                    if let Self::ValueType::Float(f) = v { Some(*f) } else { None }
                }).unwrap_or(10.0);
                ElectricNodeData::CircuitNode { name: "回路1".to_string(), power, current: 0.0 }
            },
            Self::DistributionBoxNode => {
                ElectricNodeData::DistributionBoxNode { name: "配电箱1".to_string(), total_current: 0.0 }
            },
            Self::PowerSourceNode => {
                let voltage = params.get("电压值(V)").and_then(|v| {
                    if let Self::ValueType::Float(f) = v { Some(*f) } else { None }
                }).unwrap_or(220.0);
                ElectricNodeData::PowerSourceNode { name: "电源1".to_string(), voltage }
            },
        }
    }

    fn update_node_data(&self, node_data: &mut Self::NodeData, params: &HashMap<String, Self::ValueType>) {
        // 更新节点数据逻辑
    }

    fn node_label(&self, node_data: &Self::NodeData) -> String {
        match node_data {
            ElectricNodeData::CircuitNode { name, .. } => name.clone(),
            ElectricNodeData::DistributionBoxNode { name, .. } => name.clone(),
            ElectricNodeData::PowerSourceNode { name, .. } => name.clone(),
        }
    }
}

// 5. 定义应用结构体
struct ElectricNodeGraphApp {
    graph: Graph<ElectricNodeData, ElectricDataType, ElectricValueType>,
    editor_state: egui_node_graph::GraphEditorState,
    templates: Vec<ElectricNodeTemplate>,
}

impl Default for ElectricNodeGraphApp {
    fn default() -> Self {
        Self {
            graph: Graph::default(),
            editor_state: egui_node_graph::GraphEditorState::default(),
            templates: vec![
                ElectricNodeTemplate::CircuitNode,
                ElectricNodeTemplate::DistributionBoxNode,
                ElectricNodeTemplate::PowerSourceNode,
            ],
        }
    }
}

// 6. 实现App trait
impl eframe::App for ElectricNodeGraphApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.heading("电气节点图设计工具");

            // 渲染节点编辑器
            egui_node_graph::draw_graph_editor(
                ui,
                &mut self.editor_state,
                &mut self.graph,
                &self.templates,
                |_, _| {}, // 自定义UI
            );

            // 计算按钮
            if ui.button("运行计算").clicked() {
                self.run_calculations();
            }
        });
    }
}

impl ElectricNodeGraphApp {
    fn run_calculations(&mut self) {
        // 实现简单的计算逻辑
        // 例如：从电源获取电压，计算回路电流，汇总到配电箱

        // 查找所有电源节点和电压值
        let mut voltage_map = HashMap::new();
        for (node_id, node) in &self.graph.nodes {
            if let ElectricNodeData::PowerSourceNode { name, voltage } = &node.data {
                voltage_map.insert(name.clone(), voltage);
            }
        }

        // 计算回路电流并汇总到配电箱
        for (node_id, node) in &mut self.graph.nodes.iter_mut() {
            if let ElectricNodeData::CircuitNode { name, power, current } = node.data.as_mut() {
                // 查找该回路连接的电源电压
                let mut voltage = 220.0; // 默认值
                for output_id in &node.inputs.values() {
                    if let Some(conn) = self.graph.connections.get(output_id) {
                        if let ElectricNodeData::PowerSourceNode { name: source_name, .. } =
                            &self.graph.nodes.get(&conn.from_node).unwrap().data {
                            if let Some(&v) = voltage_map.get(source_name) {
                                voltage = v;
                                break;
                            }
                        }
                    }
                }

                // 计算电流: I = P / U
                *current = *power * 1000.0 / voltage; // 转换为瓦特
            }
        }
    }
}

// 7. 主函数
fn main() -> Result<(), eframe::Error> {
    let options = eframe::NativeOptions {
        initial_window_size: Some(egui::vec2(1200.0, 800.0)),
        ..Default::default()
    };

    eframe::run_native(
        "电气节点图设计工具",
        options,
        Box::new(|_| Ok(Box::new(ElectricNodeGraphApp::default()))),
    )
}
````